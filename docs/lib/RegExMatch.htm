<!DOCTYPE HTML>
<html lang="en">
<head>
<title>RegExMatch() - Syntax &amp; Usage | AutoHotkey</title>
<meta name="description" content="The RegExMatch function determines whether a string contains a pattern (regular expression)." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>RegExMatch() <span class="ver">[v1.0.45+]</span></h1>

<p>Determines whether a string contains a pattern (regular expression).</p>

<pre class="Syntax">FoundPos := <span class="func">RegExMatch</span>(Haystack, NeedleRegEx <span class="optional">, OutputVar, StartingPos</span>)</pre>
<h2 id="Parameters">Parameters</h2>
<dl>

  <dt>Haystack</dt>
  <dd><p>The string whose content is searched.</p></dd>

  <dt>NeedleRegEx</dt>
  <dd><p>The pattern to search for, which is a Perl-compatible regular expression (PCRE). The pattern's <a href="../misc/RegEx-QuickRef.htm#Options">options</a> (if any) must be included at the beginning of the string followed by a close-parenthesis. For example, the pattern <span class="regex"><span class="red">i)</span>abc.*123</span> would turn on the case-insensitive option and search for "abc", followed by zero or more occurrences of any character, followed by "123". If there are no options, the ")" is optional; for example, <span class="regex">)abc</span> is equivalent to <span class="regex">abc</span>.</p></dd>

  <dt>OutputVar</dt>
  <dd>
    <p>If blank or omitted, no output variable will be used. Otherwise, specify the name of the output variable in which to store specific data, depending on which of the following modes is used.</p>
    <p><strong>Mode 1 (default):</strong> Specify the name of the output variable in which to store the part of <em>Haystack</em> that matched the entire pattern. If the pattern is not found (that is, if the function returns 0), this variable and all array elements below are made blank.</p>
      <p id="Array">If any <a href="../misc/RegEx-QuickRef.htm#subpat">capturing subpatterns</a> are present inside <em>NeedleRegEx</em>, their matches are stored in a <a href="../misc/Arrays.htm#pseudo">pseudo-array</a> whose base name is <em>OutputVar</em>. For example, if the variable's name is <em>Match</em>, the substring that matches the first subpattern would be stored in <em>Match1</em>, the second would be stored in <em>Match2</em>, and so on. The exception to this is <a href="#NamedSubPat">named subpatterns</a>: they are stored by name instead of number. For example, the substring that matches the named subpattern <span class="regex">(?P&lt;Year&gt;\d{4})</span> would be stored in <em>MatchYear</em>. If a particular subpattern does not match anything (or if the function returns zero), the corresponding variable is made blank.</p>
      <p>Within a <a href="../Functions.htm">function</a>, to create a pseudo-array that is global instead of local, <a href="../Functions.htm#Global">declare</a> the base name of the pseudo-array (e.g. Match) as a global variable prior to using it. The converse is true for <a href="../Functions.htm#AssumeGlobal">assume-global</a> functions. However, it is often also necessary to declare each element, due to a <a href="../Functions.htm#ArrayConfusion">common source of confusion</a>.</p>
      <p id="PosMode"><strong>Mode 2 (position-and-length):</strong> If a capital P is present in the RegEx's options -- such as <span class="regex"><span class="red">P)</span>abc.*123</span> -- the <em>length</em> of the entire-pattern match is stored in <em>OutputVar</em> (or 0 if no match). If any <a href="../misc/RegEx-QuickRef.htm#subpat">capturing subpatterns</a> are present, their positions and lengths are stored in two <a href="../misc/Arrays.htm#pseudo">pseudo-arrays</a>: <em>OutputVarPos</em> and <em>OutputVarLen</em>. For example, if the variable's base name is <em>Match</em>, the one-based <em>position</em> of the first subpattern's match would be stored in <em>MatchPos1</em>, and its length in <em>MatchLen1</em> (zero is stored in both if the subpattern was not matched or the function returns 0).  The exception to this is <a href="#NamedSubPat">named subpatterns</a>: they are stored by name instead of number (e.g. <em>MatchPosYear</em> and <em>MatchLenYear</em>).</p>
      <p id="ObjectMode"><strong>Mode 3 (match object)</strong> <span class="ver">[v1.1.05+]</span>: If a capital O is present in the RegEx's options -- such as <span class="regex"><span class="red">O)</span>abc.*123</span> -- a <a href="#MatchObject">match object</a> is stored in <em>OutputVar</em>. This object can be used to retrieve the position, length and value of the overall match and of each <a href="../misc/RegEx-QuickRef.htm#subpat">captured subpattern</a>, if present.</p>
    </dd>

  <dt>StartingPos</dt>
  <dd><p>If blank or omitted, it defaults to 1 (the beginning of <em>Haystack</em>). Otherwise, specify 2 to start at the second character, 3 to start at the third, and so on. If <em>StartingPos</em> is beyond the length of <em>Haystack</em>, the search starts at the empty string that lies at the end of <em>Haystack</em> (which typically results in no match).</p>
      <p>If <em>StartingPos</em> is less than 1, it is considered to be an offset from the end of <em>Haystack</em>. For example, 0 starts at the last character and -1 starts at the next-to-last character. If <em>StartingPos</em> tries to go beyond the left end of <em>Haystack</em>, all of <em>Haystack</em> is searched.</p>
      <p>Regardless of the value of <em>StartingPos</em>, the return value is always relative to the first character of <em>Haystack</em>. For example, the position of "abc" in "123abc789" is always 4.</p></dd>

</dl>

<h2 id="Return_Value">Return Value</h2>
<p>This function returns the position of the leftmost occurrence of <em>NeedleRegEx</em> in the string <em>Haystack</em>. Position 1 is the first character. Zero is returned if the pattern is not found. If an error occurs (such as a syntax error inside <em>NeedleRegEx</em>), an empty string is returned and <a href="../misc/ErrorLevel.htm">ErrorLevel</a> is set to one of the values <a href="#ErrorLevel">below</a> instead of 0.</p>

<h2 id="ErrorLevel">Error Handling</h2>
<p><span class="ver">[v1.1.04+]</span>: This function is able to throw an exception on failure (not to be confused with "no match found"). For more information, see <a href="Catch.htm#RuntimeErrors">Runtime Errors</a>.</p>
<p><a href="../misc/ErrorLevel.htm">ErrorLevel</a> is set to one of the following:</p>
<ul>
  <li>0, which means that no error occurred.</li>
  <li>A string in the following form: <em>Compile error N at offset M: description</em>. In that string, <em>N</em> is the PCRE error number, <em>M</em> is the position of the offending character inside the regular expression, and <em>description</em> is the text describing the error.</li>
  <li>A negative number, which means an error occurred during the <em>execution</em> of the regular expression. Although such errors are rare, the ones most likely to occur are "too many possible empty-string matches" (-22), "recursion too deep" (-21), and "reached match limit" (-8). If these happen, try to redesign the pattern to be more restrictive, such as replacing each * with a ?, +, or a limit like {0,3} wherever feasible.</li>
</ul>
<h2 id="Options">Options</h2>
<p>See <a href="../misc/RegEx-QuickRef.htm#Options">RegEx Quick Reference</a> for options such as <span class="regex"><span class="red">i)</span>abc</span>, which turns off case-sensitivity.</p>
<h2 id="MatchObject">Match Object <span class="ver">[v1.1.05+]</span></h2>
<p>If a capital O is present in the RegEx's options, a match object is stored in <em>OutputVar</em>. This object has the following methods and properties:</p>
<p><strong>Match.Pos(N):</strong> Returns the position of the overall match or a captured subpattern.</p>
<p><strong>Match.Len(N):</strong> Returns the length of the overall match or a captured subpattern.</p>
<p><strong>Match.Value(N):</strong> Returns the overall match or a captured subpattern.</p>
<p><strong>Match.Name(N):</strong> Returns the name of the given subpattern, if it has one.</p>
<p><strong>Match.Count():</strong> Returns the overall number of subpatterns.</p>
<p><strong>Match.Mark():</strong> Returns the <em>NAME</em> of the last encountered <span class="regex">(*MARK:NAME)</span>, when applicable.</p>
<p><strong>Match[N]:</strong> If <em>N</em> is 0 or a valid subpattern number or name, this is equivalent to <code>Match.Value(N)</code>. Otherwise, <em>N</em> can be the name of one of the above methods. For example, <code>Match["Pos"]</code> and <code>Match.Pos</code> are equivalent to <code>Match.Pos()</code> unless a subpattern named "Pos" exists, in which case they are equivalent to <code>Match.Value("Pos")</code>.</p>
<p><strong>Match.N:</strong> Same as above, except that <em>N</em> is an unquoted name or number.</p>
<p>For all of the above methods and properties, <em>N</em> can be any of the following:</p>
<ul>
  <li>0 for the overall match.</li>
  <li>The number of a subpattern, even one that also has a name.</li>
  <li>The name of a subpattern.</li>
</ul>
<p>Brackets [] may be used in place of parentheses () if <em>N</em> is specified.</p>

<h2 id="Performance">Performance</h2>
<p>To search for a simple substring inside a larger string, use <a href="InStr.htm">InStr()</a> because it is faster than RegExMatch().</p>
<p>To improve performance, the 100 most recently used regular expressions are kept cached in memory (in compiled form).</p>
<p>The <a href="../misc/RegEx-QuickRef.htm#Study">study option (S)</a> can sometimes improve the performance of a regular expression that is used many times (such as in a loop).</p>
<h2 id="Remarks">Remarks</h2>
<p id="NamedSubPat">A subpattern may be given a name such as the word <em>Year</em> in the pattern <span class="regex">(?P&lt;Year&gt;\d{4})</span>. Such names may consist of up to 32 alphanumeric characters and underscores. The following limitation does not apply to the "O" (match object) mode: Although named subpatterns are also available by their numbers during the RegEx operation itself (e.g. <span class="regex">\1</span> is a backreference to the string that actually matched the first capturing subpattern), they are stored in the <a href="#Array">output pseudo-array</a> <em>only</em> by name (not by number). For example, if "Year" is the first subpattern, <em>OutputVarYear</em> would be set to the matching substring, but <em>OutputVar1</em> would not be changed at all (it would retain its previous value, if any). However, if an <a href="../misc/RegEx-QuickRef.htm#subpat">unnamed subpattern</a> occurs after "Year", it would be stored in <em>OutputVar2</em>, not <em>OutputVar1</em>.</p>
<p>Most characters like abc123 can be used literally inside a regular expression. However, any of the characters in the set <code>\.*?+[{|()^$</code> must be preceded by a backslash to be seen as literal. For example, <span class="regex">\.</span> is a literal period and <span class="regex">\\</span> is a literal backslash. Escaping can be avoided by using \Q...\E. For example: <span class="regex">\QLiteral Text\E</span>.</p>
<p>Within a regular expression, special characters such as tab and newline can be escaped with either an accent (`) or a backslash (\). For example, <span class="regex">`t</span> is the same as <span class="regex">\t</span> except when the <a href="../misc/RegEx-QuickRef.htm#opt_x">x option</a> is used.</p>
<p>To learn the basics of regular expressions (or refresh your memory of pattern syntax), see the <a href="../misc/RegEx-QuickRef.htm">RegEx Quick Reference</a>.</p>
<p>AutoHotkey's regular expressions are implemented using Perl-compatible Regular Expressions (PCRE) from <a href="http://www.pcre.org/">www.pcre.org</a>.</p>
<p><span class="ver">[AHK_L 31+]</span>: Within an <a href="../Variables.htm#Expressions">expression</a>, <code>a ~= b</code> can be used as shorthand for <code>RegExMatch(a, b)</code>.</p>
<h2 id="Related">Related</h2>
<p><a href="RegExReplace.htm">RegExReplace()</a>, <a href="../misc/RegEx-QuickRef.htm">RegEx Quick Reference</a>, <a href="../misc/RegExCallout.htm">Regular Expression Callouts</a>, <a href="InStr.htm">InStr()</a>, <a href="IfInString.htm">IfInString</a>, <a href="StringGetPos.htm">StringGetPos</a>, <a href="SubStr.htm">SubStr()</a>, <a href="SetTitleMatchMode.htm#RegEx">SetTitleMatchMode RegEx</a>, <a href="https://www.autohotkey.com/forum/topic16164.html">Global matching and Grep (forum link)</a></p>
<p>Common sources of text data: <a href="FileRead.htm">FileRead</a>, <a href="URLDownloadToFile.htm">UrlDownloadToFile</a>, <a href="../misc/Clipboard.htm">Clipboard</a>, <a href="GuiControls.htm#Edit">GUI Edit controls</a></p>
<h2 id="Examples">Examples</h2>
<p>For general RegEx examples, see the <a href="../misc/RegEx-QuickRef.htm">RegEx Quick Reference</a>.</p>

<div class="ex" id="ExBasic">
<p><a class="ex_number" href="#ExBasic"></a> Reports 4, which is the position where the match was found.</p>
<pre>MsgBox % RegExMatch("xxxabc123xyz", "abc.*xyz")</pre>
</div>

<div class="ex" id="ExDollar">
<p><a class="ex_number" href="#ExDollar"></a> Reports 7 because the $ requires the match to be at the end.</p>
<pre>MsgBox % RegExMatch("abc123123", "123$")</pre>
</div>

<div class="ex" id="ExCaseInsens">
<p><a class="ex_number" href="#ExCaseInsens"></a> Reports 1 because a match was achieved via the case-insensitive option.</p>
<pre>MsgBox % RegExMatch("abc123", "i)^ABC")</pre>
</div>

<div class="ex" id="ExOutputVar">
<p><a class="ex_number" href="#ExOutputVar"></a> Reports 1 and stores "XYZ" in <var>SubPat1</var>.</p>
<pre>MsgBox % RegExMatch("abcXYZ123", "abc(.*)123", SubPat)</pre>
</div>

<div class="ex" id="ExStartingPos">
<p><a class="ex_number" href="#ExStartingPos"></a> Reports 7 instead of 1 due to the starting position 2 instead of 1.</p>
<pre>MsgBox % RegExMatch("abc123abc456", "abc\d+",, 2)</pre>
</div>

<div class="ex" id="ExObject">
<p><a class="ex_number" href="#ExObject"></a> Demonstrates the usage of the Match object.</p>
<pre>FoundPos := RegExMatch("Michiganroad 72", "O)(.*) (?&lt;nr&gt;\d+)", SubPat)  <em>; The starting "O)" turns SubPat into an object.</em>
Msgbox % SubPat.Count() ": " SubPat.Value(1) " " SubPat.Name(2) "=" SubPat["nr"]  <em>; Displays "2: Michiganroad nr=72"</em></pre>
</div>

<div class="ex" id="ExExtension">
<p><a class="ex_number" href="#ExExtension"></a> Retrieves the extension of a file. Note that <a href="SplitPath.htm">SplitPath</a> can also be used for this, which is more reliable.</p>
<pre>Path := "C:\Foo\Bar\Baz.txt"
RegExMatch(Path, "\w+$", Extension)
MsgBox % Extension  <em>; Reports "txt".</em></pre>
</div>

<div class="ex" id="ExDeref">
<p><a class="ex_number" href="#ExDeref"></a> Similar to <a href="Transform.htm#Deref">Transform Deref</a>, the following function expands variable references and <a href="../misc/EscapeChar.htm">escape sequences</a> contained inside other variables. Furthermore, this example shows how to find all matches in a string rather than stopping at the first match (similar to the g flag in JavaScript's RegEx).</p>
<pre>var1 := "abc"
var2 := 123
MsgBox % Deref("%var1%def%var2%")  <em>; Reports abcdef123.</em>

Deref(String)
{
    spo := 1
    out := ""
    while (fpo:=RegexMatch(String, "(%(.*?)%)|``(.)", m, spo))
    {
        out .= SubStr(String, spo, fpo-spo)
        spo := fpo + StrLen(m)
        if (m1)
            out .= %m2%
        else switch (m3)
        {
            case "a": out .= "`a"
            case "b": out .= "`b"
            case "f": out .= "`f"
            case "n": out .= "`n"
            case "r": out .= "`r"
            case "t": out .= "`t"
            case "v": out .= "`v"
            default: out .= m3
        }
    }
    return out SubStr(String, spo)
}</pre>
</div>

</body>
</html>
