<!DOCTYPE HTML>
<html lang="en">
<head>
<title>ComCall - Syntax &amp; Usage | AutoHotkey v2</title>
<meta name="description" content="The ComCall function calls a native COM interface method by index." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>ComCall</h1>

<p>Calls a native COM interface method by index.</p>

<pre class="Syntax">Result := <span class="func">ComCall</span>(Index, ComObject <span class="optional">, Type1, Arg1, Type2, Arg2, ReturnType</span>)</pre>
<h2>Parameters</h2>
<dl>

  <dt>Index</dt>
  <dd>
      <p>Type: <a href="../Concepts.htm#numbers">Integer</a></p>
      <p>The zero-based index of the method within the virtual function table.</p>
      <p><em>Index</em> corresponds to the position of the method within the original interface definition. Microsoft documentation usually lists methods in alphabetical order, which is not relevant. In order to determine the correct index, locate the original interface definition. This may be in a header file or type library.</p>
      <p>It is important to take into account methods which are inherited from parent interfaces. Since all COM interfaces ultimately derive from <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown">IUnknown</a>, the first three methods are always QueryInterface (0), AddRef (1) and Release (2). For example, <em>IShellItem2</em> is an extension of <em>IShellItem</em>, which starts at index 3 and contains 5 methods, so <em>IShellItem2</em>'s first method (GetPropertyStore) is at index 8.</p>
      <p class="note"><strong>Tip:</strong> For COM interfaces defined by Microsoft, try searching the Internet or Windows SDK for "<em>IInterfaceName</em><b>Vtbl</b>" - for example, "IUnknownVtbl". Microsoft's own interface definitions are accompanied by this plain-C definition of the interface's virtual function table, which lists all methods explicitly, in the correct order.</p>
      <p>Passing an invalid index may cause undefined behaviour, including (but not limited to) program termination.</p>
  </dd>
  
  <dt>ComObject</dt>
  <dd>
      <p>Type: <a href="../Concepts.htm#numbers">Integer</a> or <a href="../Concepts.htm#objects">Object</a></p>
      <p>The target COM object; that is, a COM interface pointer. The pointer value can be passed directly or encapsulated within an object with the <code>Ptr</code> property, such as a <a href="ComObject.htm">ComObj</a> with variant type VT_UNKNOWN.</p>
      <p>The interface pointer is used to locate the address of the virtual function which implements the interface method, and is also passed as a parameter. This parameter is generally not explicitly present in languages which natively support interfaces, but is shown in the C style "Vtbl" definition.</p>
      <p>Passing an invalid pointer may cause undefined behaviour, including (but not limited to) program termination.</p>
  </dd>

  <dt>Type1, Arg1</dt>
  <dd>
      <p>Type: <a href="../Concepts.htm#strings">String</a></p>
      <p>Each of these pairs represents a single parameter to be passed to the method. The number of pairs is unlimited. For <em>Type</em>, see the <a href="DllCall.htm#types">DllCall types table</a>. For <em>Arg</em>, specify the value to be passed to the method.</p>
  </dd>

  <dt>ReturnType</dt>
  <dd>
      <p>Type: <a href="../Concepts.htm#strings">String</a></p>
      <p>If omitted, the return type defaults to <a href="DllCall.htm#HRESULT">HRESULT</a>, which is most the common return type for COM interface methods. Any result indicating failure causes an exception to be thrown; therefore, the return type must not be omitted unless the actual return type is HRESULT.</p>
      <p>If the method is of a type that does not return a value (the <code>void</code> return type in C), specify "Int" or any other numeric type without any suffix (except HRESULT), and ignore the return value. As the content of the return value register is arbitrary in such cases, an exception may or may not be thrown if <em>ReturnType</em> is omitted.</p>
      <p>Otherwise, specify one of the argument types from the <a href="DllCall.htm#types">DllCall types table</a>. The <a href="DllCall.htm#asterisk">asterisk suffix</a> is also supported.</p>
      <p id="cdecl">Although ComCall supports the <em>Cdecl</em> keyword as per <a href="DllCall.htm#cdecl">DllCall</a>, it is generally not used by COM interface methods.</p>
  </dd>

</dl>

<h2>Return Value</h2>
<p>Type: <a href="../Concepts.htm#strings">String</a> or <a href="../Concepts.htm#numbers">Integer</a></p>
<p>If <em>ReturnType</em> is <a href="DllCall.htm#HRESULT">HRESULT</a> (or omitted) and the method returned an error value (as defined by the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winerror/nf-winerror-failed">FAILED macro</a>), an exception is thrown.</p>
<p>Otherwise, ComCall returns the actual value returned by the method. If the method is of a type that does not return a value (with return type defined in C as <code>void</code>), the result is undefined and should be ignored.</p>

<h2 id="Remarks">Remarks</h2>
<p>The following DllCall topics are also applicable to ComCall:</p>
<ul>
  <li><a href="DllCall.htm#types">Types of Arguments and Return Values</a></li>
  <li><a href="DllCall.htm#error">Errors</a></li>
  <li><a href="DllCall.htm#except">Native Exceptions and A_LastError</a></li>
  <li><a href="DllCall.htm#struct">Structures and Arrays</a></li>
  <li><a href="DllCall.htm#limits">Known Limitations</a></li>
  <li><a href="DllCall.htm#dotnet">.NET Framework</a></li>
</ul>

<h2>Related</h2>
<p><a href="ComObjCreate.htm">ComObjCreate</a>, <a href="ComObjQuery.htm">ComObjQuery</a>, <a href="ComObject.htm">ComObject</a>, <a href="BufferAlloc.htm">BufferAlloc</a>, <a href="../objects/Buffer.htm">Buffer object</a>, <a href="CallbackCreate.htm">CallbackCreate</a></p>

<h2>Examples</h2>

<div class="ex" id="ExTaskbar">
<p><a href="#ExTaskbar">#1</a>: Remove the active window from the taskbar for 3 seconds. Compare this to the <a href="DllCall.htm#ExTaskbar">equivalent DllCall example</a>.</p>
<pre><em>/*
  Methods in <a href="http://msdn.microsoft.com/en-us/library/bb774652.aspx">ITaskbarList</a>'s VTable:
    IUnknown:
      0 QueryInterface  -- use <a href="ComObjQuery.htm">ComObjQuery</a> instead
      1 AddRef          -- use <a href="ObjAddRef.htm">ObjAddRef</a> instead
      2 Release         -- use <a href="ObjAddRef.htm">ObjRelease</a> instead
    ITaskbarList:
      3 HrInit
      4 AddTab
      5 DeleteTab
      6 ActivateTab
      7 SetActiveAlt
*/</em>
IID_ITaskbarList  := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
CLSID_TaskbarList := "{56FDF344-FD6D-11d0-958A-006097C9A090}"

<em>; Create the TaskbarList object and store its address in tbl.</em>
tbl := <a href="ComObjCreate.htm">ComObjCreate</a>(CLSID_TaskbarList, IID_ITaskbarList)

<em>; Since an IID was specified above, tbl is a pointer (an integer).
; The pointer may be wrapped so that it will be released automatically
; when the script no longer has a reference to the wrapper object.
; This example will still work if the following line is removed:</em>
tbl := ComObject(13, tbl)

activeHwnd := WinExist("A")

ComCall(3, tbl)                     <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774650.aspx">HrInit</a>()</em>
ComCall(5, tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774648.aspx">DeleteTab</a>(activeHwnd)</em>
Sleep 3000
ComCall(4, tbl, "ptr", activeHwnd)  <em>; tbl.<a href="http://msdn.microsoft.com/en-us/library/bb774646.aspx">AddTab</a>(activeHwnd)</em>

if IsObject(tbl)  <em>; Was ComObject(13, tbl) used?</em>
{
    <em>; When finished with the object, simply replace any references with
    ; some other value (or if its a local variable, just return):</em>
    tbl := ""
}
else
{
    <em>; Since the pointer wasn't wrapped, it must be released manually
    ; (although any memory used by the object or the corresponding
    ; library would be reclaimed when the program exits, anyway).</em>
    ObjRelease(tbl)
}
</pre>
</div>

<div class="ex" id="ExTaskbarClass">
<p><a href="#ExTaskbarClass">#2</a>: Demonstrate some techniques for wrapping COM interfaces. Equivalent to the previous example.</p>
<pre>
tbl := TaskbarList.new()

activeHwnd := WinExist("A")

tbl.DeleteTab(activeHwnd)
Sleep 3000
tbl.AddTab(activeHwnd)

tbl := ""


class TaskbarList {
    static IID := "{56FDF342-FD6D-11d0-958A-006097C9A090}"
    static CLSID := "{56FDF344-FD6D-11d0-958A-006097C9A090}"
    
    <em>; Called on startup to initialize the class.</em>
    static __new() {
        <em>; Get the base object for all instances of TaskbarList.</em>
        proto := this.Prototype
        
        <em>; Bound functions can be used to predefine parameters, making
        ; the methods more usable without requiring wrapper functions.
        ; HrInit itself has no parameters, so bind only the index,
        ; and the caller will implicitly provide 'this'.</em>
        proto.DefineMethod "HrInit", Func("ComCall").Bind(3)
        
        <em>; Leave a parameter blank to let the caller provide a value.
        ; In this case, the blank parameter is 'this' (normally hidden).</em>
        proto.DefineMethod "AddTab", Func("ComCall").Bind(4,, "ptr")
        
        <em>; An object or Map can be used to reduce repetition.</em>
        for name, args in Map(
            "DeleteTab", [5,,"ptr"],
            "ActivateTab", [6,,"ptr"],
            "SetActiveAlt", [7,,"ptr"]) {
            proto.DefineMethod name, Func("ComCall").Bind(args*)
        }
    }
    
    <em>; Called by TaskbarList.new() on the new instance.</em>
    __new() {
        this.ptr := ComObjCreate(TaskbarList.CLSID, TaskbarList.IID)
        <em>; If ComObjError(0) was used, this.ptr could be zero.</em>
        if !this.ptr
            throw Exception("COM-related error")
        <em>; Request initialization via ITaskbarList.</em>
        this.HrInit()
    }
    
    <em>; Release the interface pointer when this object is deleted.</em>
    __delete() => this.ptr &amp;&amp; ObjRelease(this.ptr)
}
</pre>

</body>
</html>
