<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Objects - Definition &amp; Usage | AutoHotkey v2</title>
<meta name="description" content="How to use objects, define new types of objects, and other details about how objects work in AutoHotkey." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objects</h1>

<p>An <i>object</i> combines a number of <em>properties</em> and <a href="Concepts.htm#methods"><em>methods</em></a>.</p>
<p>Related topics:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objects</a>: General explanation of objects.</li>
  <li><a href="Concepts.htm#object-protocol">Object Protocol</a>: Specifics about how a script interacts with an object.</li>
  <li><a href="misc/Functor.htm">Function objects</a>: Objects which can be <em>called</em>.</li>
</ul>

<p><b>IsObject</b> can be used to determine if a value is an object:</p>
<pre>Result := IsObject(<i>expression</i>)</pre>

<p>See <a href="ObjList.htm">Built-in Classes</a> for a list of standard object types. There are two fundamental types:</p>
<ul>
  <li><strong>AutoHotkey objects</strong> are instances of the <a href="lib/Object.htm">Object</a> class. These support ad hoc properties, and have methods for discovering which properties exist. <a href="lib/Array.htm">Array</a>, <a href="lib/Map.htm">Map</a> and all user defined and built-in classes are derived from Object.</li>
  <li><strong>COM objects</strong> such as those created by <a href="lib/ComObject.htm">ComObject</a>. These are implemented by external libraries, so often differ in behaviour to AutoHotkey objects. ComObject typically represents a COM or "Automation" object implementing the <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch interface</a>, but is also used to <a href="lib/ComValue.htm">wrap values of specific types</a> to be passed to COM objects and functions.</li>
</ul>

<h2 id="toc">Table of Contents</h2>
<ul>
  <li><a href="#Usage">Basic Usage</a> - <a href="#Usage_Simple_Arrays">Arrays</a>, <a href="#Usage_Associative_Arrays">Maps (Associative Arrays)</a>, <a href="#Usage_Objects">Objects</a>, <a href="#Usage_Freeing_Objects">Freeing Objects</a></li>
  <li><a href="#Extended_Usage">Extended Usage</a> - <a href="#Usage_Arrays_of_Arrays">Arrays of Arrays</a></li>
  <li><a href="#Custom_Objects">Custom Objects</a> - <a href="#creating-a-base-object">Creating a Base Object</a>, <a href="#Custom_Classes">Classes</a>, <a href="#Custom_NewDelete">Construction and Destruction</a>, <a href="#Meta_Functions">Meta-Functions</a></li>
  <li><a href="#primitive">Primitive Values</a></li>
  <li><a href="#Implementation">Implementation</a> - <a href="#Reference_Counting">Reference-Counting</a>, <a href="#ObjPtr">Pointers to Objects</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Basic Usage</h2>

<h3 id="Usage_Simple_Arrays">Arrays</h3>
<p>Create an <a href="lib/Array.htm">Array</a>:</p>
<pre>MyArray := [Item1, Item2, ..., ItemN]
MyArray := Array(Item1, Item2, ..., ItemN)</pre>
<p>Retrieve an item (or <em>array element</em>):</p>
<pre>Value := MyArray[Index]</pre>
<p>Change the value of an item (<code>Index</code> must be between 1 and Length, or an equivalent reverse index):</p>
<pre>MyArray[Index] := Value</pre>
<p>Insert one or more items at a given index using the <a href="lib/Array.htm#InsertAt">InsertAt</a> method:</p>
<pre>MyArray.InsertAt(Index, Value, Value2, ...)</pre>
<p>Append one or more items using the <a href="lib/Array.htm#Push">Push</a> method:</p>
<pre>MyArray.Push(Value, Value2, ...)</pre>
<p>Remove an item using the <a href="lib/Array.htm#RemoveAt">RemoveAt</a> method:</p>
<pre>RemovedValue := MyArray.RemoveAt(Index)</pre>
<p>Remove the last item using the <a href="lib/Array.htm#Pop">Pop</a> method:</p>
<pre>RemovedValue := MyArray.Pop()</pre>
<p><a href="lib/Array.htm#Length">Length</a> returns the number of items in the array. Looping through an array's contents can be done either by index or with a For-loop. For example:</p>
<pre>MyArray := ["one", "two", "three"]

<em>; Iterate from 1 to the end of the array:</em>
Loop MyArray.Length
    MsgBox MyArray[A_Index]

<em>; Enumerate the array's contents:</em>
For index, value in MyArray
    MsgBox "Item " index " is '" value "'"
    
<em>; Same thing again:</em>
For value in MyArray
    MsgBox "Item " A_Index " is '" value "'"
</pre>

<h3 id="Usage_Associative_Arrays">Maps (Associative Arrays)</h3>
<p>A <a href="lib/Map.htm">Map</a> or associative array is an object which contains a collection of unique keys and a collection of values, where each key is associated with one value. Keys can be strings, integers or objects, while values can be of any type. An associative array can be created as follows:</p>
<pre>MyMap := Map("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>Retrieve an item, where <code>Key</code> is a <a href="Concepts.htm#variables">variable</a> or <a href="Language.htm#expressions">expression</a>:</p>
<pre>Value := MyMap[Key]</pre>
<p>Assign an item:</p>
<pre>MyMap[Key] := Value</pre>
<p>Remove an item using the <a href="lib/Array.htm#Delete">Delete</a> method:</p>
<pre>RemovedValue := MyMap.Delete(Key)</pre>
<p>Enumerating items:</p>
<pre>MyMap := Map("ten", 10, "twenty", 20, "thirty", 30)
<a href="lib/For.htm">For</a> key, value in MyMap
    MsgBox key ' = ' value</pre>

<h3 id="Usage_Objects">Objects</h3>
<p>An object can have <em>properties</em> and <em>items</em> (such as array elements). Items are accessed using <code>[]</code> as shown in the previous sections. Properties are usually accessed by writing a dot followed by an identifier (just a <a href="Concepts.htm#names">name</a>). <em>Methods</em> are properties which can be called.</p>
<p><strong>Examples:</strong></p>
<p>Retrieve or set a property literally named <em>Property</em>:</p>
<pre>Value := MyObject.Property</pre>
<pre>MyObject.Property := Value</pre>
<p>Retrieve or set a property where the name is determined by evaluating an <a href="Language.htm#expressions">expression</a> or <a href="Concepts.htm#variables">variable</a>:</p>
<pre>Value := MyObject.%Expression%</pre>
<pre>MyObject.%Expression% := Value</pre>
<p>Call a property/method literally named <em>Method</em>:</p>
<pre>ReturnValue := MyObject.Method(Parameters)</pre>
<p>Call a property/method where the name is determined by evaluating an expression or variable:</p>
<pre>ReturnValue := MyObject.%Expression%(Parameters)</pre>
<p>Sometimes parameters are accepted when retrieving or assigning properties:</p>
<pre>Value := MyObject.Property[Parameters]
MyObject.Property[Parameters] := Value</pre>
<p>An object may also support indexing: <code>MyArray[Index]</code> actually invokes the <a href="#__Item">__Item</a> property of <code>MyArray</code>, passing <code>Index</code> as a parameter.</p>

<h3 id="object-literal">Object Literal</h3>
<p>An object literal can be used within an <a href="Language.htm#expressions">expression</a> to create an improvised object. An object literal consists of a pair of braces (<code>{}</code>) enclosing a list of comma-delimited name-value pairs. Each pair consists of a literal (unquoted) <a href="Concepts.htm#names">property name</a> and a value (sub-expression) separated by a colon (<code>:</code>).  For example:</p>
<pre>Coord := {X: 13, Y: 240}</pre>
<p>This is equivalent:</p>
<pre>Coord := Object()
Coord.X := 13
Coord.Y := 240</pre>
<p>Each name-value pair causes a value property to be defined, with the exception that <a href="lib/Object.htm#Base">Base</a> can be set (with the same restrictions as a normal assignment).</p>
<p><a href="Variables.htm#deref">Name substitution</a> allows a property name to be determined by evaluating an <a href="Language.htm#expressions">expression</a> or <a href="Concepts.htm#variables">variable</a>. For example:</p>
<pre>parts := StrSplit("key = value", "=", " ")
pair := {%parts[1]%: parts[2]}
MsgBox pair.key</pre>

<h3 id="Usage_Freeing_Objects">Freeing Objects</h3>
<p>Scripts do not free objects explicitly. When the last reference to an object is released, the object is freed automatically. A reference stored in a variable is released automatically when that variable is assigned some other value. For example:</p>
<pre>obj := {}  <em>; Creates an object.</em>
obj := ""  <em>; Releases the last reference, and therefore frees the object.</em></pre>
<p>Similarly, a reference stored in a property or array element is released when that property or array element is assigned some other value or removed from the object.</p>
<pre>arr := [{}]  <em>; Creates an array containing an object.</em>
arr[1] := {}  <em>; Creates a second object, implicitly freeing the first object.</em>
arr.RemoveAt(1)  <em>; Removes and frees the second object.</em></pre>
<p id="Circular_References">Because all references to an object must be released before the object can be freed, objects containing circular references aren't freed automatically. For instance, if <code>x.child</code> refers to <code>y</code> and <code>y.parent</code> refers to <code>x</code>, clearing <code>x</code> and <code>y</code> is not sufficient since the parent object still contains a reference to the child and vice versa. To resolve this situation, remove the circular reference.</p>
<pre>
x := {}, y := {}             <em>; Create two objects.</em>
x.child := y, y.parent := x  <em>; Create a circular reference.</em>

y.parent := ""               <em>; The circular reference must be removed before the objects can be freed.</em>
x := "", y := ""             <em>; Without the above line, this would not free the objects.</em>
</pre>
<p>For more advanced usage and details, see <a href="#Reference_Counting">Reference Counting</a>.</p>

<h2 id="Extended_Usage">Extended Usage</h2>

<h3 id="Usage_Arrays_of_Arrays">Arrays of Arrays</h3>
<p>Although "multi-dimensional" arrays are not supported, a script can combine multiple arrays or maps. For example:</p>
<pre>
grid := [[1,2,3],
         [4,5,6],
         [7,8,9]]
MsgBox grid[1][3] <em>; 3</em>
MsgBox grid[3][2] <em>; 8</em>
</pre>
<p id="Array2D">A custom object can implement multi-dimensional support by defining an <a href="#__Item">__Item</a> property. For example:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Length := x * y
        this.Width := x
        this.Height := y
    }
    __Item[x, y] {
        get =&gt; super[this.Width * (y-1) + x]
        set =&gt; super[this.Width * (y-1) + x] := value
    }
}

grid := Array2D(4, 3)
grid[4, 1] := "#"
grid[3, 2] := "#"
grid[2, 2] := "#"
grid[1, 3] := "#"
gridtext := ""
Loop grid.Height {
    y := A_Index
    Loop grid.Width {
        x := A_Index
        gridtext .= grid[x, y] || "-"
    }
    gridtext .= "`n"
}
MsgBox gridtext
</pre>
<p>A real script should perform error-checking and override other methods, such as <a href="#__Enum">__Enum</a> to support enumeration.</p>

<h2 id="Custom_Objects">Custom Objects</h2>
<p>There are two general ways to create custom objects:</p>
<ul>
  <li><em>Ad hoc</em>: create an object and add properties.</li>
  <li><em>Delegation</em>: define properties in a shared <em>base object</em> or class.</li>
</ul>
<p><a href="#Meta_Functions">Meta-functions</a> can be used to further control how an object behaves.</p>
<p class="note"><strong>Note:</strong> Within this section, an <em>object</em> is any instance of the <a href="lib/Object.htm">Object</a> class. This section does not apply to COM objects.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Properties and methods (callable properties) can generally be added to new objects at any time. For example, an object with one property and one method might be constructed like this:</p>
<pre><em>; Create an object.</em>
thing := {}
<em>; Store a value.</em>
thing.foo := "bar"
<em>; Define a method.</em>
thing.test := thing_test
<em>; Call the method.</em>
thing.test()

thing_test(this) {
    MsgBox this.foo
}</pre>
<p>You could similarly create the above object with <code>thing := {foo: "bar"}</code>. When using the {property:value} notation, quote marks must not be used for properties.</p>
<p>When <code>thing.test()</code> is called, <i>thing</i> is automatically inserted at the beginning of the parameter list. By convention, the function is named by combining the "type" of object and the method name, but this is not a requirement.</p>
<p>In the example above, <em>test</em> could be assigned some other function or value after it is defined, in which case the original function is lost and cannot be called via this property. An alternative is to define a read-only method, as shown below:</p>
<pre>thing.DefineProp 'test', {call: thing_test}</pre>
<p>See also: <a href="lib/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objects are <em>prototype-based</em>. That is, any properties not defined in the object itself can instead be defined in the object's <a href="lib/Object.htm#Base">base</a>. This is known as <em>inheritance by delegation</em> or <em>differential inheritance</em>, because an object can implement only the parts that make it different, while delegating the rest to its base.</p>
<p>Although a base object is also generally known as a prototype, we use "a class's <a href="lib/Class.htm#Prototype">Prototype</a>" to mean the object upon which every instance of the class is based, and "base" to mean the object upon which an instance is based.</p>
<p class="note">AutoHotkey's object design was influenced primarily by JavaScript and Lua, with a little C#. We use <code><i>obj</i>.base</code> in place of JavaScript's <code><i>obj</i>.__proto__</code> and <code><i>cls</i>.Prototype</code> in place of JavaScript's <code><i>func</i>.prototype</code>. (Class objects are used in place of constructor functions.)</p>

<p>An object's base is also used to identify its type or class. For example, <code>x := []</code> creates an object <em>based on</em> <code>Array.Prototype</code>, which means that the expressions <code>x is Array</code> and <code>x.HasBase(Array.Prototype)</code> are true, and <code>type(x)</code> returns "Array". Each class's Prototype is based on the Prototype of its base class, so <code>x.HasBase(Object.Prototype)</code> is also true.</p>
<p>Any instance of Object or a derived class can be a base object, but an object can only be <a href="lib/Object.htm#Base">assigned as the base</a> of an object with the same native type. This is to ensure that built-in methods can always identify the native type of an object, and operate only on objects that have the correct binary structure.</p>
<p>Base objects can be defined two different ways:</p>
<ul>
  <li>By <a href="#creating-a-base-object">creating a normal object</a>.</li>
  <li>By <a href="#Custom_Classes">defining a class</a>. Each class has a <a href="lib/Class.htm#Prototype">Prototype</a> property containing an object which all instances of that class are based on, while the class itself becomes the base object of any direct subclasses.</li>
</ul>
<p>A base object can be assigned to the <a href="lib/Object.htm#Base">base</a> property of another object, but typically an object's base is set implicitly when it is created.</p>

<h3 id="creating-a-base-object">Creating a Base Object</h3>
<p>Any object can be used as the base of any other object which has the same native type. The following example builds on the previous example under <a href="#ad-hoc">Ad Hoc</a> (combine the two before running it):</p>
<pre>other := {}
other.base := thing
other.test()</pre>
<p>In this case, <i>other</i> inherits <i>foo</i> and <i>test</i> from <i>thing</i>. This inheritance is dynamic, so if <code>thing.foo</code> is modified, the change will be reflected by <code>other.foo</code>. If the script assigns to <code>other.foo</code>, the value is stored in <i>other</i> and any further changes to <code>thing.foo</code> will have no effect on <code>other.foo</code>. When <code>other.test()</code> is called, its <i>this</i> parameter contains a reference to <i>other</i> instead of <i>thing</i>.</p>

<h3 id="Custom_Classes">Classes</h3>
<blockquote>In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).
<a href="https://en.wikipedia.org/wiki/Class_(computer_programming)" class="source">Wikipedia</a></blockquote>
<p>In more general terms, a <em>class</em> is a set or category of things having some property or attribute in common. In AutoHotkey, a <code>class</code> defines properties to be shared by instances of the class (and methods, which are callable properties). An <em>instance</em> is just an object which inherits properties from the class, and can typically also be identified as belonging to that class (such as with the expression <code><i>instance</i> is <i>ClassName</i></code>). Instances are typically created by calling <a href="lib/Class.htm#Call"><em>ClassName</em>()</a>.</p>
<p>Since <a href="lib/Object.htm">Objects</a> are <a href="#ad-hoc">dynamic</a> and <a href="#delegation">prototype-based</a>, each class consists of two parts:</p>
<ul>
  <li>The class has a <a href="lib/Class.htm#Prototype">Prototype</a> object, on which all instances of the class are based. All methods and dynamic properties that apply to instances of the class are contained by the prototype object. This includes all properties and methods which lack the <code>static</code> keyword.</li>
  <li>The class itself is an object, containing only static methods and properties. This includes all properties and methods with the <code>static</code> keyword, and all nested classes. These do not apply to a specific instance, and can be used by referring to the class itself by name.</li>
</ul>
<p>The following shows most of the elements of a class definition:</p>
<pre>class ClassName extends BaseClassName
{
    InstanceVar := <i>Expression</i>
    
    static ClassVar := <i>Expression</i>

    class NestedClass
    {
        ...
    }

    Method()
    {
        ...
    }
    
    static Method()
    {
        ...
    }

    Property[<i>Parameters</i>]  <em>; Use brackets only when parameters are present.</em>
    {
        <span class="dec">get</span> {
            return <i>value of property</i>
        }
        <span class="dec">set</span> {
            <i>Store or otherwise handle</i> <span class="biv">value</span>
        }
    }
    
    ShortProperty
    {
        <span class="dec">get</span> =&gt; <i>Expression which calculates property value</i>
        <span class="dec">set</span> =&gt; <i>Expression which stores or otherwise handles</i> <span class="biv">value</span>
    }
    
    ShorterProperty =&gt; <i>Expression which calculates property value</i>
}
</pre>
<p>When the script is loaded, this constructs a <a href="lib/Class.htm">Class</a> object and stores it in a <a href="Functions.htm#Global">global</a> constant (read-only variable) with the name <i>ClassName</i>. If <code>extends BaseClassName</code> is present, <i>BaseClassName</i> must be the full name of another class. The full name of each class is stored in <code><i>ClassName</i>.Prototype.__Class</code>.</p>
<p>Because the class itself is accessed through a variable, the class name cannot be used to both reference the class and create a separate variable (such as to hold an instance of the class) in the same context. For example, <code>box := Box()</code> will not work, because <code>box</code> and <code>Box</code> both resolve to the same thing. Attempting to reassign a top-level (not nested) class in this manner results in a load time error.</p>
<p>Within this documentation, the word "class" on its own usually means a class object constructed with the <code>class</code> keyword.</p>
<p>Class definitions can contain variable declarations, method definitions and nested class definitions.</p>

<h4 id="Custom_Classes_var">Instance Variables</h4>
<p>An <em>instance variable</em> is one that each instance of the class has its own copy of. They are declared and behave like normal assignments, but the <code>this.</code> prefix is omitted (only directly within the class body):</p>
<pre>InstanceVar := Expression</pre>
<p>These declarations are evaluated each time a new instance of the class is created with <a href="lib/Class.htm#Call"><em>ClassName</em>()</a>, after all base-class declarations are evaluated but before <a href="#Custom_NewDelete">__New</a> is called. This is achieved by automatically creating a method named <em>__Init</em> containing a call to <code>super.__Init()</code> and inserting each declaration into it. Therefore, a single class definition must not contain both an __Init method and an instance variable declaration.</p>
<p><em>Expression</em> can access other instance variables and methods via <code>this</code>. Global variables may be read, but not assigned. An additional assignment (or use of the <a href="Variables.htm#ref">reference operator</a>) within the expression will generally create a variable local to the __Init method. For example, <code>x := y := 1</code> would set <code>this.x</code> and a local variable <code>y</code> (which would be freed once all initializers have been evaluated).</p>
<p>To access an instance variable (even within a method), always specify the target object; for example, <code><b>this</b>.InstanceVar</code>.</p>
<p>Declarations like <code>x.y := z</code> are also supported, provided that <code>x</code> was previously defined in this class. For example, <code>x := {}, x.y := 42</code> declares <code>x</code> and also initializes <code>this.x.y</code>.</p>

<h4 id="Custom_Classes_staticvar">Static/Class Variables</h4>
<p>Static/class variables belong to the class itself, but their values can be inherited by subclasses. They are declared like instance variables, but using the static keyword:</p>
<pre>static ClassVar := Expression</pre>
<p>These declarations are evaluated only once, when the class is <a href="#static__New">initialized</a>. A static method named <em>__Init</em> is automatically defined for this purpose.</p>
<p>Each declaration acts as a normal property assignment, with the class object as the target. <em>Expression</em> has the same interpretation as for instance variables, except that <code>this</code> refers to the class itself.</p>
<p>To assign to a class variable anywhere else, always specify the class object; for example, <code><b>ClassName</b>.ClassVar := Value</code>. If a subclass does not own a property by that name, <code><i>Subclass</i>.ClassVar</code> can also be used to retrieve the value; so if the value is a reference to an object, subclasses will share that object by default. However, <code><i>Subclass</i>.ClassVar := y</code> would store the value in <em>Subclass</em>, not in <em>ClassName</em>.</p>
<p>Declarations like <code>static x.y := z</code> are also supported, provided that <code>x</code> was previously defined in this class. For example, <code>static x := {}, x.y := 42</code> declares <code>x</code> and also initializes <code><i>ClassName</i>.x.y</code>.  Because <a href="lib/Class.htm#Prototype">Prototype</a> is implicitly defined in each class, <code>static Prototype.sharedValue := 1</code> can be used to set values which are dynamically inherited by all instances of the class (until shadowed by a property on the instance itself).</p>

<h4 id="Custom_Classes_class">Nested Classes</h4>
<p>Nested class definitions allow a class object to be associated with a static/class variable of the outer class instead of a separate global variable. In the example above, <code>class NestedClass</code> constructs a <a href="lib/Class.htm">Class</a> object and stores it in <code>ClassName.NestedClass</code>. Subclasses could inherit <em>NestedClass</em> or override it with their own nested class (in which case <code>(<i>WhichClass</i>.NestedClass)()</code> could be used to instantiate whichever class is appropriate).</p>
<pre>
class NestedClass
{
    ...
}
</pre>
<p>Nesting a class does not imply any particular relationship to the outer class. The nested class is not instantiated automatically, nor do instances of the nested class have any connection with an instance of the outer class, unless the script explicitly makes that connection.</p>
<p>However, due to the way methods work for <a href="lib/Object.htm">Objects</a>, <code><i>WhichClass</i>.NestedClass()</code> implicitly passes <em>WhichClass</em> as the first parameter, equivalent to <code><i>WhichClass</i>.NestedClass.Call(<i>WhichClass</i>)</code>. Unless <code>static Call()</code> is overridden, this parameter is automatically passed to <a href="#Custom_NewDelete">__New</a>.</p>

<h4 id="Custom_Classes_method">Methods</h4>
<p>Method definitions look identical to function definitions. Each method definition creates a <a href="lib/Func.htm">Func</a> with a hidden first parameter named <code>this</code>, and defines a property which is used to call the method or retrieve its function object.</p>
<p>There are two types of methods:</p>
<ul>
  <li>Instance methods are defined as below, and are attached to the class's <a href="lib/Class.htm#Prototype">Prototype</a>, which makes them accessible via any instance of the class. When the method is called, <code>this</code> refers to an instance of the class.</li>
  <li>Static methods are defined by preceding the method name with the separate keyword <code>static</code>. These are attached to the class object itself, but are also inherited by subclasses, so <code>this</code> refers to either the class itself or a subclass.</li>
</ul>
<p>The method definition below creates a property of the same type as <code><i>target</i>.DefineProp('Method', {call: <i>funcObj</i>})</code>. By default, <code><i>target</i>.Method</code> returns <em>funcObj</em> and attempting to assign to <code><i>target</i>.Method</code> throws an error. These defaults can be overridden by <a href="#Custom_Classes_property">defining a property</a> or calling <a href="lib/Object.htm#DefineProp">DefineProp</a>.</p>
<pre>
Method()
{
    ...
}
</pre>

<p><a href="Variables.htm#fat-arrow">Fat arrow syntax</a> can be used to define a single-line method which returns an expression:</p>
<pre>Method() =&gt; <i>Expression</i></pre>

<h4 id="Custom_Classes_super">Super</h4>
<p>Inside a method or a property getter/setter, the keyword <code>super</code> can be used in place of <code>this</code> to access the superclass versions of methods or properties which are overridden in a derived class. For example, <code>super.Method()</code> in the class defined above would typically call the version of <em>Method</em> which was defined within <em>BaseClassName</em>. Note:</p>
<ul>
  <li><code>super.Method()</code> always invokes the base of the class or prototype object associated with the current method's original definition, even if <code>this</code> is derived from a <em>subclass</em> of that class or some other class entirely.</li>
  <li><code>super.Method()</code> implicitly passes <code>this</code> as the first (hidden) parameter.</li>
  <li>Since it is not known where (or whether) <em>ClassName</em> exists within the chain of base objects, <em>ClassName</em> itself is used as the starting point. Therefore, <code>super.Method()</code> is mostly equivalent to <code>(<i>ClassName</i>.Prototype.base.Method)(this)</code> (but without <em>Prototype</em> when <em>Method</em> is static). However, <code><i>ClassName</i>.Prototype</code> is resolved at load time.</li>
  <li>An error is thrown if the property is not defined in a superclass or cannot be invoked.</li>
</ul>
<p>The keyword <code>super</code> must be followed by one of the following symbols: <code>.[(</code></p>
<p><code>super()</code> is equivalent to <code>super.call()</code>.</p>

<h4 id="Custom_Classes_property">Properties</h4>
<p>A property definition creates a <a href="lib/Object.htm#DefineProp">dynamic property</a>, which calls a method instead of simply storing or returning a value.</p>
<pre>Property[<i>Parameters</i>]
{
    <span class="dec">get</span> {
        return <i>property value</i>
    }
    <span class="dec">set</span> {
        <i>Store or otherwise handle</i> <span class="biv">value</span>
    }
}
</pre>
<p><em>Property</em> is simply the name of the property, which will be used to invoke it. For example, <code>obj.Property</code> would call <em>get</em> while <code>obj.Property := value</code> would call <em>set</em>. Within <em>get</em> or <em>set</em>, <code>this</code> refers to the object being invoked. Within <em>set</em>, <code>value</code> contains the value being assigned.</p>
<p>Parameters can be defined by enclosing them in square brackets to the right of the property name, and are passed the same way - but they should be omitted when parameters are not present (see below). Aside from using square brackets, parameters of properties are defined the same way as parameters of methods - optional, ByRef and variadic parameters are supported.</p>
<p>If a property is invoked with parameters but has none defined, parameters are automatically forwarded to the <a href="#__Item">__Item</a> property of the object returned by <em>get</em>. For example, <code>this.Property[x]</code> would have the same effect as <code>(this.Property)[x]</code> or <code>y := this.Property, y[x]</code>. Empty brackets (<code>this.Property[]</code>) always cause the __Item property <em>of Property's value</em> to be invoked, but a variadic call such as <code>this.Property[args*]</code> has this effect only if the number of parameters is non-zero.</p>
<p>Static properties can be defined by preceding the property name with the separate keyword <code>static</code>. In that case, <code>this</code> refers to the class itself or a subclass.</p>
<p>The return value of <em>set</em> is ignored. For example, <code>val := obj.Property := 42</code> always assigns <code>val := 42</code> regardless of what the property does, unless it throws an exception or exits the thread.</p>
<p>Each class can define one or both halves of a property. If a class overrides a property, it can use <code><a href="#Custom_Classes_super">super.Property</a></code> to access the property defined by its base class. If <em>Get</em> or <em>Set</em> is not defined, it can be inherited from a base object. If <em>Get</em> is undefined, the property can return a value inherited from a base. If <em>Set</em> is undefined in this and all base objects (or is obscured by an inherited value property), attempting to set the property causes an exception to be thrown.</p>
<p>A property definition with both <em>get</em> and <em>set</em> actually creates two separate functions, which do not share local or static variables or nested functions. As with methods, each function has a hidden parameter named <code>this</code>, and <em>set</em> has a second hidden parameter named <code>value</code>. Any explicitly defined parameters come after those.</p>
<p>While a property definition defines the <em>get</em> and <em>set</em> accessor functions for a property in the same way as <a href="lib/Object.htm#DefineProp">DefineProp</a>, a method definition defines the <em>call</em> accessor function. Any class may contain a property definition and a method definition with the same name. If a property without a <em>call</em> accessor function (a method) is called, <em>get</em> is invoked with no parameters and the result is then called as a method.</p>

<h4 id="Custom_Classes_property_short">Fat Arrow Properties</h4>
<p><a href="Variables.htm#fat-arrow">Fat arrow syntax</a> can be used to define a <a href="#Custom_Classes_property">property</a> getter or setter which returns an expression:</p>
<pre>ShortProperty[<i>Parameters</i>]
{
    <span class="dec">get</span> =&gt; <i>Expression which calculates property value</i>
    <span class="dec">set</span> =&gt; <i>Expression which stores or otherwise handles</i> <span class="biv">value</span>
}</pre>
<p>When defining only a getter, the braces and <code>get</code> can be omitted:</p>
<pre>ShorterProperty[<i>Parameters</i>] =&gt; <i>Expression which calculates property value</i></pre>
<p>In both cases, the square brackets must be omitted unless parameters are defined.</p>

<h3 id="__Enum">__Enum Method</h3>
<pre class="Syntax">__Enum(NumberOfVars)</pre>
<p>The __Enum method is called when the object is passed to a <a href="lib/For.htm">for-loop</a>. This method should return an <a href="lib/Enumerator.htm">enumerator</a> which will return items contained by the object, such as array elements. If left undefined, the object cannot be passed directly to a for-loop unless it has an <a href="lib/Enumerator.htm#Call">enumerator-compatible Call method</a>.</p>
<p><em>NumberOfVars</em> contains the number of variables passed to the for-loop. If <em>NumberOfVars</em> is 2, the enumerator is expected to assign the key or index of an item to the first parameter and the value to the second parameter. Each key or index should be accepted as a parameter of the <a href="#__Item">__Item</a> property. This enables <a href="AHKL_DBGPClients.htm">DBGp-based debuggers</a> to get or set a specific item after listing them by invoking the enumerator.</p>

<h3 id="__Item">__Item Property</h3>
<p>The __Item property is invoked when the indexing operator (array syntax) is used with the object. In the following example, the property is declared as static so that the indexing operator can be used on the Env class itself. For another example, see <a href="#Array2D">Array2D</a>.</p>
<pre>class Env {
    static __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

Env["PATH"] .= ";" A_ScriptDir  <em>; Only affects this script and child processes.</em>
MsgBox Env["PATH"]</pre>
<p><code>__Item</code> is effectively a default property name (if such a property has been defined):</p>
<ul>
  <li><code><i>object</i>[<i>params</i>]</code> is equivalent to <code><i>object</i>.__Item[<i>params</i>]</code> when there are parameters.</li>
  <li><code><i>object</i>[]</code> is equivalent to <code><i>object</i>.__Item</code>.</li>
</ul>
<p>For example:</p>
<pre>
obj := {}
obj[] := Map()     <em>; Equivalent to obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Note:</strong> When an explicit property name is combined with empty brackets, as in <code>obj.prop[]</code>, it is handled as two separate operations: first retrieve <code>obj.prop</code>, then invoke the default property of the result. This is part of the language syntax, so is not dependent on the object.</p>

<h3 id="Custom_NewDelete">Construction and Destruction</h3>
<p>Whenever an object is created by the default implementation of <a href="lib/Class.htm#Call"><em>ClassName</em>()</a>, the new object's <code>__New</code> method is called in order to allow custom initialization. Any parameters passed to <code><i>ClassName</i>()</code> are forwarded to <code>__New</code>, so can affect the object's initial content or how it is constructed. When an object is destroyed, <code>__Delete</code> is called. For example:</p>
<pre>m1 := GMem(0, 10)
m2 := {base: GMem.Prototype}, m2.__New(0, 30)

<em>; Note: For general memory allocations, use <a href="lib/Buffer.htm">Buffer</a>() instead.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aSize)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aSize, "Ptr")
        if !this.ptr
            throw MemoryError()
        MsgBox "New GMem of " aSize " bytes at address " this.ptr "."
    }

    __Delete()
    {
        MsgBox "Delete GMem at address " this.ptr "."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete is not called for any object which owns a property named "__Class". <a href="lib/Class.htm#Prototype">Prototype objects</a> have this property by default.</p>
<p>If an exception or runtime error is thrown while __Delete is executing and is not handled within __Delete, it acts as though __Delete was called from a new <a href="misc/Threads.htm">thread</a>. That is, an error dialog is displayed and __Delete returns, but the thread does not exit (unless it was already exiting).</p>
<p>If the script is directly terminated by any means, including the tray menu or <a href="lib/ExitApp.htm">ExitApp</a>, any functions which have yet to return do not get the chance to do so. Therefore, any objects referenced by local variables of those functions are not released, so __Delete is not called.</p>
<p>When the script exits, objects contained by global and static variables are released automatically in an arbitrary, implementation-defined order. When __Delete is called during this process, some global or static variables may have already been released, but any references contained by the object itself are still valid. It is therefore best for __Delete to be entirely self-contained, and not rely on any global or static variables.</p>

<h4 id="static__New">Class Initialization</h4>
<p>Each class is initialized automatically when a reference to the class is evaluated for the first time. For example, if <em>MyClass</em> has not yet been initialized, <code>MyClass.MyProp</code> would cause the class to be initialized before the property is retrieved. Initialization consists of calling two static methods: __Init and __New.</p>
<p><code>static __Init</code> is defined automatically for every class, and always begins with a reference to the base class if one was specified, to ensure it is initialized. <a href="#Custom_Classes_staticvar">Static/class variables</a> and <a href="#Custom_Classes_class">nested classes</a> are initialized in the order that they were defined, except when a nested class is referenced during initialization of a previous variable or class.</p>
<p>If the class defines or inherits a <code>static __New</code> method, it is called immediately after __Init. It is important to note that __New may be called once for the class in which it is defined <em>and</em> once for each subclass which does not define its own (or which calls <code>super.__New()</code>). This can be used to perform common initialization tasks for each subclass, or modify subclasses in some way before they are used.</p>
<p>If <code>static __New</code> is not intended to act on derived classes, that can be avoided by checking the value of <code>this</code>. In some cases it may be sufficient for the method to delete itself, such as with <code>this.DeleteProp('__New')</code>; however, the first execution of __New might be for a subclass if one is nested in the base class or referenced during initialization of a static/class variable.</p>
<p>A class definition also has the effect of referencing the class. In other words, when execution reaches a class definition during <a href="Scripts.htm#auto">script startup</a>, __Init and __New are called automatically, unless the class was already referenced by the script. However, if execution is prevented from reaching the class definition, such as by <code>return</code> or an infinite loop, the class is initialized only if it is referenced.</p>
<p>Once automatic initialization begins, it will not occur again for the same class. This is generally not a problem unless multiple classes refer to each other. For example, consider the two classes below. When <code>A</code> is initialized first, evaluating <code>B.SharedArray</code> (A1) causes <code>B</code> to be initialized before retrieving and returning the value, but <code>A.SharedValue</code> (A3) is undefined and does not cause initialization of <code>A</code> because it is already in progress. In other words, if <code>A</code> is accessed or initialized first, the order is A1 to A3; otherwise it is B1 to B4:</p>
<pre>MsgBox A.SharedArray.Length
MsgBox B.SharedValue

class A {
    static SharedArray := B.SharedArray   <em>; A1          ; B3</em>
    static SharedValue := 42                            <em>; B4</em>
}

class B {
    static SharedArray := StrSplit("XYZ") <em>; A2          ; B1</em>
    static SharedValue := A.SharedValue   <em>; A3 (Error)  ; B2</em>
}</pre>

<h3 id="Meta_Functions">Meta-Functions</h3>
<pre class="Syntax">
class <i>ClassName</i> {
    __Get(Name, Params)
    __Set(Name, Params, Value)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>The name of the property or method.</p></dd>
  <dt>Params</dt>
  <dd><p>An <a href="lib/Array.htm">Array</a> of parameters. This includes only the parameters between <code>()</code> or <code>[]</code>, so may be empty. The meta-function is expected to handle cases such as <code>x.y[z]</code> where <code>x.y</code> is undefined.</p></dd>
  <dt>Value</dt>
  <dd><p>The value being assigned.</p></dd>
</dl>
<p>Meta-functions define what happens when an undefined property or method is invoked. For example, if <code>obj.unk</code> has not been assigned a value, it invokes the <i>__Get</i> meta-function. Similarly, <code>obj.unk := value</code> invokes <i>__Set</i> and <code>obj.unk()</code> invokes <i>__Call</i>.</p>
<p>Properties and methods can be defined in the object itself or any of its <a href="#delegation">base objects</a>. In general, for a meta-function to be called for every property, one must avoid defining any properties. Built-in properties such as <a href="lib/Object.htm#Base">Base</a> can be overridden with a <a href="#Custom_Classes_property">property definition</a> or <a href="lib/Object.htm#DefineProp">DefineProp</a>.</p>
<p>If a meta-function is defined, it must perform whatever default action is required. For example, the following might be expected:</p>
<ul>
  <li><i>Call</i>: Throw a <a href="lib/Error.htm#MethodError">MethodError</a>.</li>
  <li>If parameters were given, throw an exception (there's no object to forward the parameters to).</li>
  <li><i>Get</i>: Throw a <a href="lib/Error.htm#PropertyError">PropertyError</a>.</li>
  <li><i>Set</i>: Define a new property with the given value, such as by calling <a href="lib/Object.htm#DefineProp">DefineProp</a>. </li>
</ul>
<p>Any <a href="misc/Functor.htm">callable object</a> can be used as a meta-function by assigning it to the relevant property.</p>
<p>Meta-functions are not called in the following cases:</p>
<ul>
  <li><code>x[y]</code>: Using square brackets without a property name only invokes the <a href="#__Item">__Item</a> property.</li>
  <li><code>x()</code>: Calling the object itself only invokes the <code>Call</code> method. This includes internal calls made by built-in functions such as <a href="lib/SetTimer.htm">SetTimer</a> and <a href="lib/Hotkey.htm">Hotkey</a>.</li>
  <li>Internal calls to other meta-functions or double-underscore methods do not trigger <code>__Call</code>.</li>
</ul>

<h4 id="Dynamic_Properties">Dynamic Properties</h4>
<p><a href="#Custom_Classes_property">Property syntax</a> and <a href="lib/Object.htm#DefineProp">DefineProp</a> can be used to define properties which compute a value each time they are evaluated, but each property must be defined in advance. By contrast, <em>__Get</em> and <em>__Set</em> can be used to implement properties which are known only at the moment they are invoked.</p>
<p>For example, a "proxy" object could be created which sends requests for properties over the network (or through some other channel). A remote server would send back a response containing the value of the property, and the proxy would return the value to its caller. Even if the name of each property was known in advance, it would not be logical to define each property individually in the proxy class since every property does the same thing (send a network request). Meta-functions receive the property name as a parameter, so are a good solution to this problem.</p>

<h2 id="primitive">Primitive Values</h2>
<p>Primitive values, such as strings and numbers, cannot have their own properties and methods. However, primitive values support the same kind of <a href="#delegation">delegation</a> as objects. That is, any property or method call on a primitive value is delegated to a predefined prototype object, which is also accessible via the <a href="lib/Class.htm#Prototype">Prototype</a> property of the corresponding class. The following classes relate to primitive values:</p>
<ul style="line-height: 1.5">
  <li>Primitive (extends <a href="lib/Any.htm">Any</a>) <ul style="padding-left: 1.7em">
    <li>Number <ul style="padding-left: 1.7em">
      <li>Float</li>
      <li>Integer</li>
    </ul></li>
    <li>String</li>
  </ul></li>
</ul>
<p>Although checking the <a href="lib/Type.htm">Type</a> string is generally faster, the type of a value can be tested by checking whether it has a given base. For example, <code>n.HasBase(Number.Prototype)</code> or <code>n is Number</code> is true if <em>n</em> is a pure Integer or Float, but not if <em>n</em> is a numeric string, since String does not derive from Number. By contrast, <code>IsNumber(n)</code> is true if <em>n</em> is a number or a numeric string.</p>
<p><a href="lib/Any.htm#GetBase">ObjGetBase</a> and the <a href="lib/Any.htm#Base">Base</a> property return one of the predefined prototype objects when appropriate.</p>
<p>Note that <code>x is Any</code> would ordinarily be true for any value within AutoHotkey's type hierarchy, but false for COM objects.</p>

<h3 id="primitive-extension">Adding Properties and Methods</h3>
<p>Properties and methods can be added for all values of a given type by modifying that type's prototype object. However, since a primitive value is not an Object and cannot have its own properties or methods, the primitive prototype objects do not derive from <code>Object.Prototype</code>. In other words, methods such as <a href="lib/Object.htm#DefineProp">DefineProp</a> and <a href="lib/Object.htm#HasOwnProp">HasOwnProp</a> are not accessible by default. They can be called indirectly. For example:</p>
<pre>
DefProp := {}.DefineProp
DefProp( "".base, "Length", { get: StrLen } )
MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
</pre>
<p>Although primitive values can inherit value properties from their prototype, an exception is thrown if the script attempts to set a value property on a primitive value. For example:</p>
<pre>"".base.test := 1  <em>; Don't try this at home.</em>
MsgBox "".test  <em>; 1</em>
"".test := 2  <em>; Error: Property is read-only.</em></pre>
<p>Although __Set and property setters can be used, they are not useful since primitive values should be considered immutable.</p>

<h2 id="Implementation">Implementation</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Reference-Counting</h3>
<p>AutoHotkey uses a basic reference-counting mechanism to automatically free the resources used by an object when it is no longer referenced by the script.  Script authors should not invoke this mechanism explicitly, except when dealing directly with unmanaged <a href="#ObjPtr">pointers to objects</a>.</p>
<p>Temporary references returned by functions, methods or operators within an expression are released after evaluation of that expression has completed or been aborted. In the following example, the new <a href="#GMem">GMem</a> object is freed only after MsgBox has returned:</p>
<pre>MsgBox <a href="lib/DllCall.htm">DllCall</a>("GlobalSize", "ptr", GMem(0, 20).ptr, "ptr")  <em>; 20</em></pre>
<p class="note"><strong>Note:</strong> In this example, <code>.ptr</code> could have been omitted since the <a href="lib/DllCall.htm#ptr">Ptr</a> arg type permits objects with a <code>Ptr</code> property. However, the pattern shown above will work even with other property names.</p>
<p>To run code when the last reference to an object is being released, implement the <a href="#Custom_NewDelete">__Delete</a> meta-function.</p>
<p><b>Known Limitations:</b></p>
<ul>
  <li>Circular references must be broken before an object can be freed. For details and an example, see <a href="#Circular_References">Freeing Objects</a>.</li>
  <li>Although references in static and global variables are released automatically when the program exits, references in non-static local variables or on the expression evaluation stack are not.  These references are only released if the function or expression is allowed to complete normally.</li>
</ul>
<p>Although memory used by the object is reclaimed by the operating system when the program exits, <a href="#Custom_NewDelete">__Delete</a> will not be called unless all references to the object are freed.  This can be important if it frees other resources which are not automatically reclaimed by the operating system, such as temporary files.</p>

<h3 id="ObjPtr">Pointers to Objects</h3>
<p>In some rare cases it may be necessary to pass an object to external code via DllCall or store it in a binary data structure for later retrieval. An object's address can be retrieved via <code>address := ObjPtr(myObject)</code>; however, this effectively makes two references to the object, but the program only knows about the one in <em>myObject</em>. If the last <em>known</em> reference to the object was released, the object would be deleted. Therefore, the script must inform the object that it has gained a reference. This can be done as follows (the two lines below are equivalent):</p>
<pre>
ObjAddRef(address := ObjPtr(myObject))
address := ObjPtrAddRef(myObject)
</pre>
<p>The script must also inform the object when it is finished with that reference:</p>
<pre>ObjRelease(address)</pre>
<p>Generally each new copy of an object's address should be treated as another reference to the object, so the script should call ObjAddRef when it gains a copy and ObjRelease immediately before losing one. For example, whenever an address is copied via something like <code>x := address</code>, ObjAddRef should be called. Similarly, when the script is finished with <em>x</em> (or is about to overwrite <em>x</em>'s value), it should call ObjRelease.</p>
<p id="ObjFromPtr">To convert an address to a proper reference, use the ObjFromPtr function:</p>
<pre>myObject := ObjFromPtr(address)</pre>
<p>ObjFromPtr assumes that <em>address</em> is a counted reference, and claims ownership of it. In other words, <code>myObject := ""</code> would cause the reference originally represented by <em>address</em> to be released. After that, <em>address</em> must be considered invalid. To instead make a new reference, use one of the following:</p>
<pre>
ObjAddRef(address), myObject := ObjFromPtr(address)
myObject := ObjFromPtrAddRef(address)
</pre>

</body>
</html>
