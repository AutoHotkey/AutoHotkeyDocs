<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Objects - Definition &amp; Usage | AutoHotkey v2</title>
<meta name="description" content="How to use objects, define new types of objects, and other details about how objects work in AutoHotkey." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objects</h1>

<p class="warning"><strong>Note:</strong> This page is a work in progress.</p>

<p>An <i>object</i> combines a number of <em>properties</em> and <a href="Concepts.htm#methods"><em>methods</em></a>.</p>
<p>Related topics:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objects</a>: General explanation of objects.</li>
  <li><a href="Concepts.htm#object-protocol">Object Protocol</a>: Specifics about how a script interacts with an object.</li>
  <li><a href="objects/Functor.htm">Function objects</a>: Objects which can be <em>called</em>.</li>
</ul>

<p><b>IsObject</b> can be used to determine if a value is an object:</p>
<pre>Result := IsObject(<i>expression</i>)</pre>

<p>See <em>Object Types</em> in the documentation side bar for a list of standard object types. There are two fundamental types:</p>
<ul>
  <li><strong>AutoHotkey objects</strong> are instances of the <a href="objects/Object.htm">Object</a> class. These support ad hoc properties and methods, and have methods for discovering which properties and methods exist. <a href="objects/Array.htm">Array</a>, <a href="objects/Map.htm">Map</a> and all user defined and built-in classes are derived from Object.</li>
  <li><strong>COM objects</strong> such as those created by <a href="commands/ComObjCreate.htm">ComObjCreate</a>. These are implemented by external libraries, so often differ in behaviour to AutoHotkey objects. ComObject typically represents a COM or "Automation" object implementing the <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch interface</a>, but is also used to <a href="commands/ComObject.htm">wrap values of specific types</a> to be passed to COM objects and functions.</li>
</ul>

<h2>Table of Contents</h2>
<ul>
  <li><a href="#Usage">Basic Usage</a> - <a href="#Usage_Simple_Arrays">Arrays</a>, <a href="#Usage_Associative_Arrays">Maps (Associative Arrays)</a>, <a href="#Usage_Objects">Objects</a>, <a href="#Usage_Freeing_Objects">Freeing Objects</a></li>
  <li><a href="#Extended_Usage">Extended Usage</a> - <a href="#Function_References">Function References</a>, <a href="#Usage_Arrays_of_Arrays">Arrays of Arrays</a></li>
  <li><a href="#Custom_Objects">Custom Objects</a> - <a href="#creating-a-base-object">Creating a Base Object</a>, <a href="#Custom_Classes">Classes</a>, <a href="#Custom_NewDelete">Construction and Destruction</a>, <a href="#Meta_Functions">Meta-Functions</a></li>
  <li><a href="#primitive">Primitive Values</a></li>
  <li><a href="#Implementation">Implementation</a> - <a href="#Reference_Counting">Reference-Counting</a>, <a href="#Implementation_Pointers">Pointers to Objects</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Basic Usage</h2>

<h3 id="Usage_Simple_Arrays">Arrays</h3>
<p>Create an <a href="objects/Array.htm">Array</a>:</p>
<pre>MyArray := [Item1, Item2, ..., ItemN]
MyArray := Array(Item1, Item2, ..., ItemN)</pre>
<p>Retrieve an item (or <em>array element</em>):</p>
<pre>Value := MyArray[Index]</pre>
<p>Change the value of an item (must already exist in the array):</p>
<pre>MyArray[Index] := Value</pre>
<p>Insert one or more items at a given index using the <a href="objects/Array.htm#InsertAt">InsertAt</a> method:</p>
<pre>MyArray.InsertAt(Index, Value, Value2, ...)</pre>
<p>Append one or more items using the <a href="objects/Array.htm#Push">Push</a> method:</p>
<pre>MyArray.Push(Value, Value2, ...)</pre>
<p>Remove an item using the <a href="objects/Array.htm#RemoveAt">RemoveAt</a> method:</p>
<pre>RemovedValue := MyArray.RemoveAt(Index)</pre>
<p>Remove the last item using the <a href="objects/Array.htm#Pop">Pop</a> method:</p>
<pre>RemovedValue := MyArray.Pop()</pre>
<p><a href="objects/Array.htm#Length">Length</a> returns the number of items in the array. Looping through an array's contents can be done either by index or with a For-loop. For example:</p>
<pre>MyArray := ["one", "two", "three"]

<em>; Iterate from 1 to the end of the array:</em>
Loop MyArray.Length
    MsgBox MyArray[A_Index]

<em>; Enumerate the array's contents:</em>
For index, value in MyArray
    MsgBox "Item " index " is '" value "'"
    
<em>; Same thing again:</em>
For value in MyArray
    MsgBox "Item " A_Index " is '" value "'"
</pre>

<h3 id="Usage_Associative_Arrays">Maps (Associative Arrays)</h3>
<p>A <a href="objects/Map.htm">Map</a> or associative array is an object which contains a collection of unique keys and a collection of values, where each key is associated with one value. Keys can be strings, integers or objects, while values can be of any type. An associative array can be created as follows:</p>
<pre>MyMap := Map("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>Retrieve an item, where <code>Key</code> is a <a href="Concepts.htm#variables">variable</a> or <a href="Language.htm#expressions">expression</a>:</p>
<pre>Value := MyMap[Key]</pre>
<p>Assign an item:</p>
<pre>MyMap[Key] := Value</pre>
<p>Remove an item using the <a href="objects/Array.htm#Delete">Delete</a> method:</p>
<pre>RemovedValue := MyMap.Delete(Key)</pre>
<p>Enumerating items:</p>
<pre>MyMap := Map("ten", 10, "twenty", 20, "thirty", 30)
<a href="commands/For.htm">For</a> key, value in MyMap
    MsgBox key ' = ' value</pre>

<h3 id="Usage_Objects">Objects</h3>
<p>An object can have <em>properties</em>, <em>methods</em> and <em>items</em> (such as array elements). Items are accessed using <code>[]</code> as shown in the previous sections. Properties and methods are usually accessed by writing a dot followed by an identifier (just a <a href="Concepts.htm#names">name</a>).</p>
<p><strong>Examples:</strong></p>
<p>Retrieve or set a property literally named <em>Property</em>:</p>
<pre>Value := Object.Property</pre>
<pre>Object.Property := Value</pre>
<p>Retrieve or set a property where the name is determined by evaluating an <a href="Language.htm#expressions">expression</a> or <a href="Concepts.htm#variables">variable</a>:</p>
<pre>Value := Object.%Expression%</pre>
<pre>Object.%Expression% := Value</pre>
<p>Call a method literally named <em>Method</em>:</p>
<pre>ReturnValue := Object.Method(Parameters)</pre>
<p>Call a method where the name is determined by evaluating an expression or variable:</p>
<pre>ReturnValue := Object.%Expression%(Parameters)</pre>
<p>Some properties can accept parameters:</p>
<pre>Value := Object.Property[Parameters]
Object.Property[Parameters] := Value</pre>
<p>In fact, the array indexing syntax <code>MyArray[Index]</code> actually invokes the <code>__Item</code> property of <code>MyArray</code>, passing <code>Index</code> as a parameter.</p>

<h3 id="Usage_Freeing_Objects">Freeing Objects</h3>
<p>Scripts do not free objects explicitly. When the last reference to an object is released, the object is freed automatically. A reference stored in a variable is released automatically when that variable is assigned some other value. For example:</p>
<pre>obj := {}  <em>; Creates an object.</em>
obj := ""  <em>; Releases the last reference, and therefore frees the object.</em></pre>
<p>Similarly, a reference stored in a property or array element is released when that property or array element is assigned some other value or removed from the object.</p>
<pre>arr := [{}]  <em>; Creates an array containing an object.</em>
arr[1] := {}  <em>; Creates a second object, implicitly freeing the first object.</em>
arr.RemoveAt(1)  <em>; Removes and frees the second object.</em></pre>
<p id="Circular_References">Because all references to an object must be released before the object can be freed, objects containing circular references aren't freed automatically. For instance, if <code>x.child</code> refers to <code>y</code> and <code>y.parent</code> refers to <code>x</code>, clearing <code>x</code> and <code>y</code> is not sufficient since the parent object still contains a reference to the child and vice versa. To resolve this situation, remove the circular reference.</p>
<pre>
x := {}, y := {}             <em>; Create two objects.</em>
x.child := y, y.parent := x  <em>; Create a circular reference.</em>

y.parent := ""               <em>; The circular reference must be removed before the objects can be freed.</em>
x := "", y := ""             <em>; Without the above line, this would not free the objects.</em>
</pre>
<p>For more advanced usage and details, see <a href="#Reference_Counting">Reference Counting</a>.</p>

<h2 id="Extended_Usage">Extended Usage</h2>
<h3 id="Function_References">Function References</h3>
<p>If the variable <i>func</i> contains a function name, the function can be called with the expression <code><a href="Functions.htm#DynCall">%func%()</a></code>. However, this requires the function name to be resolved each time, which is inefficient if the function is called more than once. To improve performance, the script can retrieve a reference to the function and store it for later use:</p>
<pre>MyFuncRef := Func("MyFunc")</pre>
<p>A function can be called by reference using the following syntax:</p>
<pre>
RetVal := <a href="Functions.htm#DynCall">%MyFuncRef%</a>(<i>Params</i>)
RetVal := MyFuncRef.<a href="objects/Func.htm#Call">Call</a>(<i>Params</i>)
</pre>
<p>For details about additional properties of function references, see <a href="objects/Func.htm">Func Object</a>.</p>
<p>In most cases, any <a href="objects/Functor.htm">callable object</a> can be used in place of a function reference.</p>

<h3 id="Usage_Arrays_of_Arrays">Arrays of Arrays</h3>
<p>Although "multi-dimensional" arrays are not supported, a script can combine multiple arrays or maps. For example:</p>
<pre>
grid := [[1,2,3],
         [4,5,6],
         [7,8,9]]
MsgBox grid[1][3] <em>; 3</em>
MsgBox grid[3][2] <em>; 8</em>
</pre>
<p>A custom object can implement multi-dimensional support by defining an __Item property. For example:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Length := x * y
        this.Width := x
        this.Height := y
    }
    __Item[x, y] {
        get => base[this.Width * (y-1) + x]
        set => base[this.Width * (y-1) + x] := value
    }
}

grid := Array2D.new(3, 4)
grid[1, 4] := "#"
grid[2, 3] := "#"
grid[2, 2] := "#"
grid[3, 1] := "#"
gridtext := ""
Loop grid.Width {
    x := A_Index
    Loop grid.Height {
        y := A_Index
        gridtext .= grid[x, y] || "-"
    }
    gridtext .= "`n"
}
MsgBox gridtext
</pre>
<p>A real script should perform error-checking and override other methods, such as <a href="#__Enum">__Enum</a> to support enumeration.</p>

<h2 id="Custom_Objects">Custom Objects</h2>
<p>There are two general ways to create custom objects:</p>
<ul>
  <li><em>Ad hoc</em>: create an object and add properties and methods.</li>
  <li><em>Delegation</em>: define properties and methods in a shared <em>base object</em> or class.</li>
</ul>
<p><a href="#Meta_Functions">Meta-functions</a> can be used to further control how an object behaves.</p>
<p class="note"><strong>Note:</strong> Within this section, an <em>object</em> is any instance of the <a href="objects/Object.htm">Object</a> class. This section does not apply to COM objects.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Properties and methods can generally be added to new objects at any time. For example, an object with one property and one method might be constructed like this:</p>
<pre><em>; Create an object.</em>
thing := {}
<em>; Store a value.</em>
thing.foo := "bar"
<em>; Define a method.</em>
thing.DefineMethod "test", Func("thing_test")
<em>; Call the method.</em>
thing.test()

thing_test(this) {
    MsgBox this.foo
}</pre>
<p>When <code>thing.test()</code> is called, <i>thing</i> is automatically inserted at the beginning of the parameter list. By convention, the function is named by combining the "type" of object and the method name, but this is not a requirement.</p>
<p>See also: <a href="objects/Object.htm#DefineMethod">DefineMethod</a>, <a href="objects/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objects are <em>prototype-based</em>. That is, any properties or methods not defined in the object itself can instead be defined in the object's <a href="objects/Object.htm#Base">base</a>. This is known as <em>inheritance by delegation</em> or <em>differential inheritance</em>, because an object can implement only the parts that make it different, while delegating the rest to its base.</p>
<p>Although a base object is also generally known as a prototype, we use "a class's <a href="objects/Class.htm#Prototype">Prototype</a>" to mean the object upon which every instance of the class is based, and "base" to mean the object upon which an instance is based (or sometimes the <a href="#Custom_Classes_base">base class/superclass</a> of the current class).</p>
<p class="note">AutoHotkey's object design was influenced primarily by JavaScript and Lua, with a little C#. We use <code><i>obj</i>.base</code> in place of JavaScript's <code><i>obj</i>.__proto__</code> and <code><i>cls</i>.Prototype</code> in place of JavaScript's <code><i>func</i>.prototype</code>. (Class objects are used in place of constructor functions.)</p>

<p>An object's base is also used to identify its type or class. For example, <code>x := []</code> creates an object <em>based on</em> <code>Array.Prototype</code>, which means that the expressions <code>x is Array</code> and <code>x.HasBase(Array.Prototype)</code> are true, and <code>type(x)</code> returns "Array".</p>
<p>Any instance of Object or a derived class can be a base object, but an object can only be <a href="objects/Object.htm#Base">assigned as the base</a> of an object with the same native type. This is to ensure that built-in methods can always identify the native type of an object, and operate only on objects that have the correct binary structure.</p>
<p>Base objects can be defined two different ways:</p>
<ul>
  <li>By <a href="#creating-a-base-object">creating a normal object</a>.</li>
  <li>By <a href="#Custom_Classes">defining a class</a>. Each class has a <a href="objects/Class.htm#Prototype">Prototype</a> property containing an object which all instances of that class are based on, while the class itself becomes the base object of any direct subclasses.</li>
</ul>
<p>A base object can be assigned to the <a href="objects/Object.htm#Base">base</a> property of another object, but typically an object's base is set implicitly when it is created.</p>

<h3 id="creating-a-base-object">Creating a Base Object</h3>
<p>Any object can be used as the base of any other object which has the same native type. The following example builds on the previous example under <a href="#ad-hoc">Ad Hoc</a> (combine the two before running it):</p>
<pre>other := {}
other.base := thing
other.test()</pre>
<p>In this case, <i>other</i> inherits <i>foo</i> and <i>test</i> from <i>thing</i>. This inheritance is dynamic, so if <code>thing.foo</code> is modified, the change will be reflected by <code>other.foo</code>. If the script assigns to <code>other.foo</code>, the value is stored in <i>other</i> and any further changes to <code>thing.foo</code> will have no effect on <code>other.foo</code>. When <code>other.test()</code> is called, its <i>this</i> parameter contains a reference to <i>other</i> instead of <i>thing</i>.
</p>

<h3 id="Custom_Classes">Classes</h3>
<blockquote>In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).
<a href="https://en.wikipedia.org/wiki/Class_(computer_programming)" class="source">Wikipedia</a></blockquote>
<p>In more general terms, a <em>class</em> is a set or category of things having some property or attribute in common. In AutoHotkey, a <code>class</code> defines properties and methods to be shared by instances of the class. An <em>instance</em> is just an object which inherits properties and methods from the class, and can typically also be identified as belonging to that class (such as with the expression <code><i>instance</i> is <i>ClassName</i></code>). Instances are typically created by calling <a href="objects/Class.htm#New"><em>ClassName</em>.new()</a>.</p>
<p>Since <a href="objects/Object.htm">Objects</a> are <a href="#ad-hoc">dynamic</a> and <a href="#delegation">prototype-based</a>, each class consists of two parts:</p>
<ul>
  <li>The class has a <a href="objects/Class.htm#Prototype">Prototype</a> object, on which all instances of the class are based. All methods and properties that apply to a specific instance are contained by the prototype object. This includes all properties and methods which lack the <code>static</code> keyword.</li>
  <li>The class itself is an object, containing only static methods and properties. This includes all properties and methods with the <code>static</code> keyword, and all nested classes. These do not apply to a specific instance, and can be used by referring to the class itself by name.</li>
</ul>
<p>The following shows most of the elements of a class definition:</p>
<pre>class ClassName extends BaseClassName
{
    InstanceVar := <i>Expression</i>
    
    static ClassVar := <i>Expression</i>

    class NestedClass
    {
        ...
    }

    Method()
    {
        ...
    }
    
    static Method()
    {
        ...
    }

    Property[]  <em>; Brackets are optional</em>
    {
        <span class="dec">get</span> {
            return <i>value of property</i>
        }
        <span class="dec">set</span> {
            <i>Store or otherwise handle</i> <span class="biv">value</span>
        }
    }
    
    ShortProperty[]
    {
        <span class="dec">get</span> =&gt; <i>Expression which calculates property value</i>
        <span class="dec">set</span> =&gt; <i>Expression which stores or otherwise handles</i> <span class="biv">value</span>
    }
    
    ShorterProperty[] =&gt; <i>Expression which calculates property value</i>
}
</pre>
<p>When the script is loaded, this constructs a <a href="objects/Class.htm">Class</a> object and stores it in the <a href="Functions.htm#SuperGlobal">super-global</a> variable <i>ClassName</i>. To reference this class inside a <a href="Functions.htm#ForceLocal">force-local</a> function, a declaration such as <code>global ClassName</code> is required. If <code>extends BaseClassName</code> is present, <i>BaseClassName</i> must be the full name of another class. The full name of each class is stored in <code><i>ClassName</i>.Prototype.__Class</code>.</p>
<p>Because the class is referenced via a variable, the class name cannot be used to both reference the class and create a separate variable (such as to hold an instance of the class) in the same context. For example, <code>box := new Box</code> would replace the class object in <em>Box</em> with an instance of itself. <a href="commands/_Warn.htm#ClassOverwrite">#Warn ClassOverwrite</a> enables a warning to be shown at load time for each attempt to overwrite a class.</p>
<p>Within this documentation, the word "class" on its own usually means a class object constructed with the <code>class</code> keyword.</p>
<p>Class definitions can contain variable declarations, method definitions and nested class definitions.</p>

<h4 id="Custom_Classes_var">Instance Variables</h4>
<p>An <em>instance variable</em> is one that each instance of the class has its own copy of. They are declared like normal assignments, but the <code>this.</code> prefix is omitted (only directly within the class body):</p>
<pre>InstanceVar := Expression</pre>
<p>These declarations are evaluated each time a new instance of the class is created with the <a href="#Custom_NewDelete">new</a> keyword or <a href="objects/Class.htm#New"><em>ClassName</em>.new()</a>, after all base-class declarations are evaluated but before <a href="#Custom_NewDelete">__New</a> is called. This is achieved by automatically creating a method named <em>__Init</em> containing a call to <code>base.__Init()</code> and inserting each declaration into it. Therefore, a single class definition must not contain both an __Init method and an instance variable declaration.</p>
<p><em>Expression</em> can access other instance variables and methods via <code>this</code>, but all other variable references are assumed to be global.</p>
<p>To access an instance variable (even within a method), always specify the target object; for example, <code><b>this</b>.InstanceVar</code>.</p>
<p>Declarations like <code>x.y := z</code> are also supported, provided that <code>x</code> was previously declared in this class. For example, <code>x := {}, x.y := 42</code> declares <code>x</code> and also initializes <code>this.x.y</code>.</p>

<h4 id="Custom_Classes_staticvar">Static/Class Variables</h4>
<p>Static/class variables belong to the class itself, but their values can be inherited by subclasses. They are declared like instance variables, but using the static keyword:</p>
<pre>static ClassVar := Expression</pre>
<p>These declarations are evaluated only once, when the class is initialized. In the current release, classes are initialized in the order that they appear in the script, before evaluation of the <a href="Scripts.htm#auto">auto-execute section</a> and before any static declarations contained by functions. A static method named <em>__Init</em> is automatically defined for this purpose.</p>
<p>Each declaration stores a value in the class object. Any variable references in <i>Expression</i> are assumed to be global.</p>
<p>To assign to a class variable, always specify the class object; for example, <code><b>ClassName</b>.ClassVar := Value</code>. If a subclass does not own a property by that name, <code><i>Subclass</i>.ClassVar</code> can also be used to retrieve the value; so if the value is a reference to an object, subclasses will share that object by default. However, <code><i>Subclass</i>.ClassVar := y</code> would store the value in <em>Subclass</em>, not in <em>ClassName</em>.</p>
<p>Declarations like <code>static x.y := z</code> are also supported, provided that <code>x</code> was previously declared in this class. For example, <code>static x := {}, x.y := 42</code> declares <code>x</code> and also initializes <code><i>ClassName</i>.x.y</code>.</p>

<h4 id="Custom_Classes_class">Nested Classes</h4>
<p>Nested class definitions allow a class object to be associated with a static/class variable of the outer class instead of a separate global variable. In the example above, <code>class NestedClass</code> constructs a <a href="objects/Class.htm">Class</a> object and stores it in <code>ClassName.NestedClass</code>. Subclasses could inherit <em>NestedClass</em> or override it with their own nested class (in which case <code><i>WhichClass</i>.NestedClass.new()</code> could be used to instantiate whichever class is appropriate).</p>
<pre>
class NestedClass
{
    ...
}
</pre>
<p>Nesting a class does not imply any particular relationship to the outer class. The nested class is not instantiated automatically, nor do instances of the nested class have any connection with an instance of the outer class, unless the script explicitly makes that connection.</p>

<h4 id="Custom_Classes_method">Methods</h4>
<p>Method definitions look identical to function definitions. Each method has a hidden parameter named <code>this</code>, which contains a reference to the object on which the method was called. There are two types of methods:</p>
<ul>
  <li>Instance methods are defined as below, and are attached to the class's <a href="objects/Class.htm#Prototype">Prototype</a>, which makes them accessible via any instance of the class. When the method is called, <code>this</code> refers to an instance of the class.</li>
  <li>Static methods are defined by preceding the method name with the separate keyword <code>static</code>. These are attached to the class object itself, but are also inherited by subclasses, so <code>this</code> refers to either the class itself or a subclass.</li>
</ul>
<pre>
Method()
{
    ...
}
</pre>

<p id="Custom_Classes_base">Inside a method, the pseudo-keyword <code>base</code> can be used to access the superclass versions of methods or properties which are overridden in a derived class. For example, <code>base.Method()</code> in the class defined above would call the version of <em>Method</em> which is defined by <em>BaseClassName</em>. <a href="#Meta_Functions">Meta-functions</a> are not called unless they are explicitly named. Note:</p>
<ul>
  <li><code>base.Method()</code> always invokes the base of the class where the current method was defined, even if <code>this</code> is derived from a <em>subclass</em> of that class or some other class entirely.</li>
  <li><code>base.Method()</code> implicitly passes <code>this</code> as the first (hidden) parameter.</li>
</ul>
<p><code>base</code> only has special meaning if followed by a dot <code>.</code> or brackets <code>[]</code>, so code like <code>obj := base, obj.Method()</code> will not work. Scripts can disable the special behaviour of <i>base</i> by assigning it a non-empty value; however, this is not recommended.</p>

<p><a href="Variables.htm#fat-arrow">Fat arrow syntax</a> can be used to define a single-line method which returns an expression:</p>
<pre>Method() =&gt; <i>Expression</i></pre>
<p>See also: <a href="objects/Object.htm#DefineMethod">DefineMethod</a></p>

<h4 id="Custom_Classes_property">Properties</h4>
<p>A property definition creates a <a href="objects/Object.htm#DefineProp">dynamic property</a>, which calls a method instead of simply storing or returning a value.</p>
<pre>Property[]  <em>; Brackets are optional</em>
{
    <span class="dec">get</span> {
        return <i>property value</i>
    }
    <span class="dec">set</span> {
        <i>Store or otherwise handle</i> <span class="biv">value</span>
    }
}
</pre>
<p><em>Property</em> is simply the name of the property, which will be used to invoke it. For example, <code>obj.Property</code> would call <em>get</em> while <code>obj.Property := value</code> would call <em>set</em>. Within <em>get</em> or <em>set</em>, <code>this</code> refers to the object being invoked. Within <em>set</em>, <code>value</code> contains the value being assigned.</p>
<p>Parameters can be defined by enclosing them in square brackets to the right of the property name, and are passed the same way. Aside from using square brackets, parameters of properties are defined the same way as parameters of methods - optional, ByRef and variadic parameters are supported.</p>
<p>If a property cannot accept parameters (the square brackets are omitted or empty), parameters are automatically forwarded to the <a href="#__Item">__Item</a> property of the object returned by <em>get</em>. For example, <code>this.Property[x]</code> would have the same effect as <code>(this.Property)[x]</code> or <code>y := this.Property, y[x]</code>.</p>
<p>Static properties can be defined by preceding the property name with the separate keyword <code>static</code>. In that case, <code>this</code> refers to the class itself or a subclass.</p>
<p>The return value of <em>set</em> is ignored. For example, <code>val := obj.Property := 42</code> always assigns <code>val := 42</code> regardless of what the property does, unless it throws an exception or exits the thread.</p>
<p>Each class can define one or both halves of a property. If a class overrides a property, it can use <code><a href="#Custom_Classes_base">base.Property</a></code> to access the property defined by its base class. If <em>Get</em> or <em>Set</em> is not defined, it can be inherited from a base object. If <em>Get</em> is undefined, the property can return a value inherited from a base. If <em>Set</em> is undefined in this and all base objects, the property is read-only (attempting to set the property throws an exception).</p>
<p>Internally, <em>get</em> and <em>set</em> are two separate methods, so cannot share variables (except by storing them in <code>this</code>).</p>
<p>See also: <a href="objects/Object.htm#DefineProp">DefineProp</a></p>
<p><a href="#Meta_Functions">Meta-functions</a> provide a broader way of controlling access to properties and methods of an object, but are more complicated and error-prone.</p>

<h4 id="Custom_Classes_property_short">Fat Arrow Properties</h4>
<p><a href="Variables.htm#fat-arrow">Fat arrow syntax</a> can be used to define a <a href="#Custom_Classes_property">property</a> getter or setter which returns an expression:</p>
<pre>ShortProperty[]
{
    <span class="dec">get</span> =&gt; <i>Expression which calculates property value</i>
    <span class="dec">set</span> =&gt; <i>Expression which stores or otherwise handles</i> <span class="biv">value</span>
}</pre>
<p>When defining only a getter, the braces and <code>get</code> can be omitted:</p>
<pre>ShorterProperty[] =&gt; <i>Expression which calculates property value</i></pre>

<h3 id="__Enum">__Enum Method</h3>
<pre class="Syntax">__Enum(NumberOfVars)</pre>
<p>The __Enum method is called when the object is passed to a <a href="commands/For.htm">for-loop</a>. This method should return an <a href="objects/Enumerator.htm">enumerator</a> which will return items contained by the object, such as array elements. If left undefined, the object cannot be passed directly to a for-loop.</p>
<p><em>NumberOfVars</em> contains the number of variables passed to the for-loop. If <em>NumberOfVars</em> is 2, the enumerator is expected to assign the key or index of an item to the first parameter and the value to the second parameter. Each key or index should be accepted as a parameter of the <a href="#__Item">__Item</a> property. This enables <a href="AHKL_DBGPClients.htm">DBGp-based debuggers</a> to get or set a specific item after listing them by invoking the enumerator.</p>

<h3 id="__Item">__Item Property</h3>
<p>The __Item property is invoked when the indexing operator (array syntax) is used with the object. For example:</p>
<pre>class Env {
    __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

Env["PATH"] .= ";" A_ScriptDir  <em>; Only affects this script and child processes.</em>
MsgBox Env["PATH"]</pre>
<p><code>__Item</code> is effectively a default property name (if such a property has been defined):</p>
<ul>
  <li><code><i>object</i>[<i>params</i>]</code> is equivalent to <code><i>object</i>.__Item[<i>params</i>]</code> when there are parameters.</li>
  <li><code><i>object</i>[]</code> is equivalent to <code><i>object</i>.__Item</code>.</li>
</ul>
<p>For example:</p>
<pre>
obj := {}
obj[] := Map()     <em>; Equivalent to obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Note:</strong> When an explicit property name is combined with empty brackets, as in <code>obj.prop[]</code>, it is handled as two separate operations: first retrieve <code>obj.prop</code>, then invoke the default property of the result. This is part of the language syntax, so is not dependent on the object.</p>

<h3 id="Custom_NewDelete">Construction and Destruction</h3>
<p>Whenever an object is created by the default implementation of <a href="objects/Class.htm#New"><em>ClassName</em>.new()</a>, the new object's <code>__New</code> method is called in order to allow custom initialization. Any parameters passed to <code>new</code> are forwarded to <code>__New</code>, so can affect the object's initial content or how it is constructed. When an object is destroyed, <code>__Delete</code> is called. For example:</p>
<pre>m1 := GMem.new(0, 10)
m2 := {base: GMem.Prototype}, m2.__New(0, 30)

<em>; Note: For general memory allocations, use <a href="commands/BufferAlloc.htm">BufferAlloc</a>() instead.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aSize)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aSize, "Ptr")
        if !this.ptr
            throw Exception("Out of memory")
        MsgBox "New GMem of " aSize " bytes at address " this.ptr "."
    }

    __Delete()
    {
        MsgBox "Delete GMem at address " this.ptr "."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete is not called for any object which owns a property named "__Class". <a href="objects/Class.htm#Prototype">Prototype objects</a> have this property by default.</p>
<p>If an exception or runtime error is thrown while __Delete is executing and is not handled within __Delete, it acts as though __Delete was called from a new <a href="misc/Threads.htm">thread</a>. That is, an error dialog is displayed and __Delete returns, but the thread does not exit (unless it was already exiting).</p>
<p>Each class may also have a <code>static __New</code> method, which is called immediately after its <a href="#Custom_Classes_staticvar">static variables</a> are initialized (this occurs in the order that classes are defined in the script). This method can be inherited from a base class, and can therefore be used to initialize subclasses. Within <code>static __New</code>, <code>this</code> refers to either the class which defined the method, or a subclass.</p>

<h3 id="Meta_Functions">Meta-Functions</h3>
<pre class="Syntax">
class <i>ClassName</i> {
    __Get(Name, Params)
    __Set(Name, Params, Value)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>The name of the property or method.</p></dd>
  <dt>Params</dt>
  <dd><p>An <a href="objects/Array.htm">Array</a> of parameters. This includes only the parameters between <code>()</code> or <code>[]</code>, so may be empty. The meta-function is expected to handle cases such as <code>x.y[z]</code> where <code>x.y</code> is undefined.</p></dd>
  <dt>Value</dt>
  <dd><p>The value being assigned.</p></dd>
</dl>
<p>Meta-functions define what happens when an undefined property or method is invoked. For example, if <code>obj.unk</code> has not been assigned a value, it invokes the <i>__Get</i> meta-function. Similarly, <code>obj.unk := value</code> invokes <i>__Set</i> and <code>obj.unk()</code> invokes <i>__Call</i>.</p>
<p>Properties and methods can be defined in the object itself or any of its <a href="#delegation">base objects</a>. In general, for a meta-function to be called for every property, one must avoid defining any properties. Built-in properties such as <a href="objects/Object.htm#Base">Base</a> can be overridden with a <a href="#Custom_Classes_property">property definition</a> or <a href="objects/Object.htm#DefineProp">DefineProp</a>.</p>
<p>If a meta-function is defined, it must perform whatever default action is required. For example, the following might be expected:</p>
<ul>
  <li><i>Call</i>: Throw an "Unknown method" exception.</li>
  <li>If parameters were given, throw an exception (there's no object to forward the parameters to).</li>
  <li><i>Get</i>: Return an empty string (functions do this by default when <code>return</code> is omitted).</li>
  <li><i>Set</i>: Define a new property with the given value, such as by calling <a href="objects/Object.htm#RawSet">ObjRawSet</a>. </li>
</ul>
<p>Any <a href="objects/Functor.htm">callable object</a> can be used as a meta-function by passing it to <a href="objects/Object.htm#DefineMethod">DefineMethod</a>.</p>
<p>Meta-functions are never called when the property or method name is omitted:</p>
<ul>
  <li>For <code>x[y]</code>, define an <code>__Item</code> property instead (it should accept at least one parameter).</li>
  <li>For <code>%x%()</code>, define a <code>Call</code> method instead.</li>
</ul>

<h4 id="Dynamic_Properties">Dynamic Properties</h4>
<p><a href="#Custom_Classes_property">Property syntax</a> and <a href="objects/Object.htm#DefineProp">DefineProp</a> can be used to define properties which compute a value each time they are evaluated, but each property must be defined in advance. By contrast, <em>__Get</em> and <em>__Set</em> can be used to implement properties which are known only at the moment they are invoked.</p>
<p>For example, a "proxy" object could be created which sends requests for properties over the network (or through some other channel). A remote server would send back a response containing the value of the property, and the proxy would return the value to its caller. Even if the name of each property was known in advance, it would not be logical to define each property individually in the proxy class since every property does the same thing (send a network request). Meta-functions receive the property name as a parameter, so are a good solution to this problem.</p>

<h2 id="primitive">Primitive Values</h2>
<p>Primitive values, such as strings and numbers, cannot have their own properties and methods. However, primitive values support the same kind of <a href="#delegation">delegation</a> as objects. That is, any property or method call on a primitive value is delegated to the <em>prototype object</em> corresponding to that value's type, or in other words, the value's <em>base object</em>. The following prototype objects exist:</p>
<ul style="line-height: 1.5">
  <li>Any <ul style="padding-left: 1.7em">
    <li>Primitive <ul style="padding-left: 1.7em">
      <li>Number <ul style="padding-left: 1.7em">
        <li>Float</li>
        <li>Integer</li>
      </ul>
      <li>String</li>
    </ul>
  </ul>
</ul>
<p>However, these objects are currently only accessible through the <code>base</code> property of a primitive value (or a derived prototype object). <a href="objects/Object.htm">Object.Prototype</a> is also based on the Any prototype, so any methods or properties defined on that prototype are inherited by values of all types except ComObject. Similarly, all primitive values inherit from Primitive, and all numbers inherit from Number.</p>
<p>Although checking the <a href="commands/Type.htm">Type</a> string is generally faster, the type of a value can be tested by checking whether it has a given base. For example, <code>n.HasBase(0.base.base)</code> is true if <em>n</em> is a pure Integer or Float, but not if n is a numeric string, since the String prototype does not derive from the Number prototype. By contrast, <code>n is 'number'</code> is true if <em>n</em> is a number or a numeric string.</p>
<p>Rather than referring to the prototype objects via numbers and strings, the following code can be used to create the missing classes:</p>
<pre><em>; Define primitive classes.</em>
global Any := Class.new()
     , Primitive := Class.new()
     , String := Class.new()
     , Number := Class.new()
     , Integer := Class.new()
     , Float := Class.new()

<em>; Define hierarchy for primitive classes.</em>
Primitive.base := Any
  , Number.base := Primitive
    , Integer.base := Number
    , Float.base := Number
  , String.base := Primitive

<em>; Attach the existing prototype objects.</em>
Any.Prototype := (
    Primitive.Prototype := (
      Number.Prototype := (
        Integer.Prototype := 0.base,
        Float.Prototype := 0.0.base
      ).base,
      String.Prototype := "".base
    ).base
  ).base
</pre>
<p>The <code>is</code> operator can be used with these classes. For example, <code>n is Number</code> is equivalent to <code>n.HasBase(Number.Prototype)</code> except when the HasBase method has been overridden for <em>n</em>. Note that <code>x is Any</code> would ordinarily be true for any value within AutoHotkey's type hierarchy, but false for COM objects.</p>

<h3 id="primitive-extension">Adding Properties and Methods</h3>
<p>Properties and methods can be added for all values of a given type by modifying that type's prototype object. However, since a primitive value is not an Object and cannot have its own properties or methods, the primitive prototype objects do not derive from <code>Object.Prototype</code>. In other words, methods such as <a href="objects/Object.htm#DefineProp">DefineProp</a> and <a href="objects/Object.htm#DefineMethod">DefineMethod</a> are not accessible by default. They can be called indirectly. For example:</p>
<pre>
DefProp := {}.GetMethod("DefineProp")
%DefProp%( "".base, "Length", { get: Func("StrLen") } )
MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
</pre>
<p>Although primitive values can inherit value properties from their prototype, an exception is thrown if the script attempts to set a value property on a primitive value. For example:</p>
<pre>"".base.test := 1  <em>; Don't try this at home.</em>
MsgBox "".test  <em>; 1</em>
"".test := 2  <em>; Error: Property is read-only.</em></pre>
<p>Although __Set and property setters can be used, they are not useful since primitive values should be considered immutable.</p>

<h2 id="Implementation">Implementation</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Reference-Counting</h3>
<p>AutoHotkey uses a basic reference-counting mechanism to automatically free the resources used by an object when it is no longer referenced by the script.  Script authors should not invoke this mechanism explicitly, except when dealing directly with unmanaged <a href="#Implementation_Pointers">pointers to objects</a>.</p>
<p>Temporary references returned by functions, methods or operators within an expression are released after evaluation of that expression has completed or been aborted. In the following example, the new <a href="#GMem">GMem</a> object is freed only after MsgBox has returned:</p>
<pre>MsgBox <a href="commands/DllCall.htm">DllCall</a>("GlobalSize", "ptr", GMem.new(0, 20).ptr, "ptr")  <em>; 20</em></pre>
<p class="note"><strong>Note:</strong> In this example, <code>.ptr</code> could have been omitted since the <a href="commands/DllCall.htm#ptr">Ptr</a> arg type permits objects with a <code>Ptr</code> property. However, the pattern shown above will work even with other property names.</p>
<p>To run code when the last reference to an object is being released, implement the <a href="#Custom_NewDelete">__Delete</a> meta-function.</p>
<p><b>Known Limitations:</b></p>
<ul>
  <li>Circular references must be broken before an object can be freed. For details and an example, see <a href="#Circular_References">Freeing Objects</a>.</li>
  <li>Although references in static and global variables are released automatically when the program exits, references in non-static local variables or on the expression evaluation stack are not.  These references are only released if the function or expression is allowed to complete normally.</li>
</ul>
<p>Although memory used by the object is reclaimed by the operating system when the program exits, <a href="#Custom_NewDelete">__Delete</a> will not be called unless all references to the object are freed.  This can be important if it frees other resources which are not automatically reclaimed by the operating system, such as temporary files.</p>

<span id="AddressCast"></span><h3 id="Implementation_Pointers">Pointers to Objects</h3>
<p>In some rare cases it may be necessary to pass an object to external code via DllCall or store it in a binary data structure for later retrieval. An object's address can be retrieved via <code>address := &amp;object</code>; however, this effectively makes two references to the object, but the program only knows about the one in <em>object</em>. If the last <em>known</em> reference to the object was released, the object would be deleted. Therefore, the script must inform the object that it has gained a reference. This can be done as follows:</p>
<pre><a href="commands/ObjAddRef.htm">ObjAddRef</a>(address := &amp;object)</pre>
<p>The script must also inform the object when it is finished with that reference:</p>
<pre><a href="commands/ObjAddRef.htm">ObjRelease</a>(address)</pre>
<p>Generally each new copy of an object's address should be treated as another reference to the object, so the script should call ObjAddRef when it gains a copy and ObjRelease immediately before losing one. For example, whenever an address is copied via something like <code>x := address</code>, ObjAddRef should be called. Similarly, when the script is finished with <em>x</em> (or is about to overwrite <em>x</em>'s value), it should call ObjRelease.</p>
<p>To convert an address to a proper reference, use the Object function:</p>
<pre>MyObject := Object(address)</pre>
<p>Note that the Object function can be used even on objects which it did not create, such as <a href="commands/ComObjCreate.htm">COM objects</a> and <a href="objects/File.htm">File objects</a>.</p>

</body>
</html>
